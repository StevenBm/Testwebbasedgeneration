<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Weighted Matrix Graph Quiz</title>
<link rel="stylesheet" href="quiz-universal.css">
<script src="../src/multi-quiz-system.js"></script>
</head>
<body>
<div class="container">
  <div class="header-row">
    <h2>Match the Weighted Matrix to its Graph</h2>
    <div class="score-controls">
      <div id="scoreDisplay"></div>
      <button class="reset-btn" onclick="resetScore()">Reset Score</button>
    </div>
  </div>
  
  <div class="graph-type-badge">
    <span id="graphType"></span>
  </div>
  
  <div id="target"></div>
  
  <h3 id="instructionText">Select the correct graph visualization:</h3>
  
  <div class="options" id="choices"></div>
  
  <div class="feedback" id="feedback"></div>
  
  <div class="button-container">
    <button class="submit-btn" id="submitBtn" onclick="submitAnswer()" disabled>Submit Answer</button>
	<button class="next-btn" id="nextBtn">Next Question →</button>
  </div>
</div>

<script>

// --- Configuration ---
const MATRIX_SIZE = 6;
const density = 0.35; // Control edge density (0-1)
const UNDIRECTED_FREQUENCY = 0.7; // Probability of generating an undirected graph (0-1)
const MIN_WEIGHT = 0.1;
const MAX_WEIGHT = 0.9;
const RANDOM_NODE_POSITIONS = false; // Set to true for random node positions (harder), false for circular layout

// Randomly determine if this question is undirected or directed
const UNDIRECTED = Math.random() < UNDIRECTED_FREQUENCY;

// Generate random weighted matrix
function generateRandomMatrix(size) {
  const matrix = [];
  for (let i = 0; i < size; i++) {
    matrix[i] = [];
    for (let j = 0; j < size; j++) {
      matrix[i][j] = 0;
    }
  }
  
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      if (i === j) {
        matrix[i][j] = 0; // No self-loops
      } else if (UNDIRECTED && j < i) {
        // For undirected graphs, copy from upper triangle
        matrix[i][j] = matrix[j][i];
      } else {
        if (Math.random() < density) {
          // Generate weight with 1 significant figure (0.1 to 0.9)
          const weight = Math.round((Math.random() * (MAX_WEIGHT - MIN_WEIGHT) + MIN_WEIGHT) * 10) / 10;
          matrix[i][j] = weight;
          // If undirected, mirror the weight
          if (UNDIRECTED) {
            matrix[j][i] = weight;
          }
        } else {
          matrix[i][j] = 0;
        }
      }
    }
  }
  return matrix;
}

// Generate a wrong answer by permuting the matrix
function generateWrongMatrix(correctMatrix, size) {
  let wrongMatrix;
  let attempts = 0;
  const maxAttempts = 20;
  
  do {
    wrongMatrix = JSON.parse(JSON.stringify(correctMatrix)); // Deep clone
    const method = Math.floor(Math.random() * 3);
    
    if (method === 0) {
      // Swap two random rows
      const row1 = Math.floor(Math.random() * size);
      const row2 = Math.floor(Math.random() * size);
      if (row1 !== row2) {
        [wrongMatrix[row1], wrongMatrix[row2]] = [wrongMatrix[row2], wrongMatrix[row1]];
      }
    } else if (method === 1) {
      // Swap two random columns
      const col1 = Math.floor(Math.random() * size);
      const col2 = Math.floor(Math.random() * size);
      if (col1 !== col2) {
        for (let i = 0; i < size; i++) {
          [wrongMatrix[i][col1], wrongMatrix[i][col2]] = [wrongMatrix[i][col2], wrongMatrix[i][col1]];
        }
      }
    } else {
      // Transpose for directed graphs only
      if (!UNDIRECTED) {
        const temp = [];
        for (let i = 0; i < size; i++) {
          temp[i] = [];
          for (let j = 0; j < size; j++) {
            temp[i][j] = wrongMatrix[j][i];
          }
        }
        wrongMatrix = temp;
      } else {
        // For undirected, swap both row and column pair
        const idx1 = Math.floor(Math.random() * size);
        const idx2 = Math.floor(Math.random() * size);
        if (idx1 !== idx2) {
          // Swap rows
          [wrongMatrix[idx1], wrongMatrix[idx2]] = [wrongMatrix[idx2], wrongMatrix[idx1]];
          // Swap columns
          for (let i = 0; i < size; i++) {
            [wrongMatrix[i][idx1], wrongMatrix[i][idx2]] = [wrongMatrix[i][idx2], wrongMatrix[i][idx1]];
          }
        }
      }
    }
    
    attempts++;
  } while (matricesEqual(wrongMatrix, correctMatrix, size) && attempts < maxAttempts);
  
  return wrongMatrix;
}

// Check if two matrices are equal
function matricesEqual(m1, m2, size) {
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      if (Math.abs(m1[i][j] - m2[i][j]) > 0.01) {
        return false;
      }
    }
  }
  return true;
}

// Display matrix as table
function displayMatrix(matrix, size) {
  let html = '<div class="matrix-display"><table>';
  
  // Header row with column numbers
  html += '<tr><td class="label-cell"></td>';
  for (let j = 0; j < size; j++) {
    html += `<td class="label-cell">${j + 1}</td>`;
  }
  html += '</tr>';
  
  // Data rows with row numbers
  for (let i = 0; i < size; i++) {
    html += '<tr>';
    html += `<td class="label-cell">${i + 1}</td>`;
    for (let j = 0; j < size; j++) {
      const value = matrix[i][j];
      const cssClass = value > 0 ? 'connected' : 'disconnected';
      const displayValue = value > 0 ? value.toFixed(1) : '0';
      html += `<td class="${cssClass}">${displayValue}</td>`;
    }
    html += '</tr>';
  }
  html += '</table>';

  html += '</div>';
  return html;
}

// Draw weighted graph on canvas
function drawGraph(canvas, matrix, size, nodePositions = null) {
  const ctx = canvas.getContext('2d');
  const width = 280;
  const height = 280;
  canvas.width = width;
  canvas.height = height;
  
  ctx.clearRect(0, 0, width, height);
  
  // Calculate node positions
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) / 2 - 50;
  
  const nodes = [];
  
  if (nodePositions) {
    // Use provided positions
    for (let i = 0; i < size; i++) {
      nodes.push({
        x: nodePositions[i].x,
        y: nodePositions[i].y,
        label: i
      });
    }
  } else {
    // Generate circular layout
    for (let i = 0; i < size; i++) {
      const angle = (i / size) * 2 * Math.PI - Math.PI / 2;
      nodes.push({
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
        label: i
      });
    }
  }
  
  // Draw edges with thickness based on weight and curves to avoid overlaps
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      const weight = matrix[i][j];
      if (weight > 0) {
        const startX = nodes[i].x;
        const startY = nodes[i].y;
        const endX = nodes[j].x;
        const endY = nodes[j].y;
        
        const dx = endX - startX;
        const dy = endY - startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const unitX = dx / dist;
        const unitY = dy / dist;
        
        const nodeRadius = 20;
        const adjustedStartX = startX + unitX * nodeRadius;
        const adjustedStartY = startY + unitY * nodeRadius;
        const adjustedEndX = endX - unitX * nodeRadius;
        const adjustedEndY = endY - unitY * nodeRadius;
        
        // Line thickness based on weight (1-6 pixels)
        const lineWidth = 1 + (weight / MAX_WEIGHT) * 5;
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = lineWidth;
        
        // Check if this edge might pass through other nodes (collinearity check)
        let passesThrough = false;
        for (let k = 0; k < size; k++) {
          if (k === i || k === j) continue;
          
          const nodeK = nodes[k];
          // Calculate distance from node k to the line segment i-j
          const lineLen = dist;
          const t = Math.max(0, Math.min(1, 
            ((nodeK.x - startX) * dx + (nodeK.y - startY) * dy) / (lineLen * lineLen)
          ));
          const projX = startX + t * dx;
          const projY = startY + t * dy;
          const distToLine = Math.sqrt(
            (nodeK.x - projX) * (nodeK.x - projX) + 
            (nodeK.y - projY) * (nodeK.y - projY)
          );
          
          // If a node is too close to the line, we need to curve
          if (distToLine < 35) {
            passesThrough = true;
            break;
          }
        }
        
        // Calculate curve for the edge
        // For undirected graphs, only draw one edge per pair
        // For directed graphs, curve based on whether reverse edge exists
        let shouldCurve = passesThrough; // Always curve if passing through nodes
        let curveDirection = 1;
        let curveAmount = passesThrough ? Math.min(0, dist * 0.25) : Math.min(0, dist * 0.15);
        
        if (UNDIRECTED) {
          // For undirected, only draw if i < j to avoid duplicate edges
          if (i >= j) continue;
        } else {
          // For directed, add curve if there's a reverse edge
          if (matrix[j][i] > 0) {
            shouldCurve = true;
            curveAmount = Math.min(0, dist * 0.25); // Stronger curve for bidirectional
            curveDirection = i < j ? 1 : -1;
          }
        }
        
        // Always add some curve for visual clarity
        if (!shouldCurve) {
          shouldCurve = true;
          curveAmount = Math.min(25, dist * 0.12);
          curveDirection = (i + j) % 2 === 0 ? 1 : -1;
        }
        
        ctx.beginPath();
        
        if (shouldCurve) {
          // Calculate control point for quadratic curve
          const midX = (adjustedStartX + adjustedEndX) / 2;
          const midY = (adjustedStartY + adjustedEndY) / 2;
          
          // Perpendicular offset
          const perpX = -dy / dist;
          const perpY = dx / dist;
          
          const controlX = midX + perpX * curveAmount * curveDirection;
          const controlY = midY + perpY * curveAmount * curveDirection;
          
          ctx.moveTo(adjustedStartX, adjustedStartY);
          ctx.quadraticCurveTo(controlX, controlY, adjustedEndX, adjustedEndY);
        } else {
          ctx.moveTo(adjustedStartX, adjustedStartY);
          ctx.lineTo(adjustedEndX, adjustedEndY);
        }
        
        ctx.stroke();
        
        // Draw arrow (only for directed graphs)
        if (!UNDIRECTED) {
          let arrowX = adjustedEndX;
          let arrowY = adjustedEndY;
          let angle;
          
          if (shouldCurve) {
            // Calculate tangent angle at the end of the curve
            const midX = (adjustedStartX + adjustedEndX) / 2;
            const midY = (adjustedStartY + adjustedEndY) / 2;
            const perpX = -dy / dist;
            const perpY = dx / dist;
            const controlX = midX + perpX * curveAmount * curveDirection;
            const controlY = midY + perpY * curveAmount * curveDirection;
            
            // Tangent from control point to end point
            const tangentX = adjustedEndX - controlX;
            const tangentY = adjustedEndY - controlY;
            angle = Math.atan2(tangentY, tangentX);
          } else {
            angle = Math.atan2(dy, dx);
          }
          
          const arrowSize = 8 + weight * 4;
          
          ctx.lineWidth = Math.max(2, lineWidth * 0.7);
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(
            arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
          );
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(
            arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
          );
          ctx.stroke();
        }
      }
    }
  }
  
  // Draw nodes
  for (let i = 0; i < size; i++) {
    ctx.fillStyle = '#667eea';
    ctx.beginPath();
    ctx.arc(nodes[i].x, nodes[i].y, 20, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2.5;
    ctx.stroke();
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(i+1, nodes[i].x, nodes[i].y);
  }
}

// Generate question matrix
const correctMatrix = generateRandomMatrix(MATRIX_SIZE);

// Generate random node positions with collision detection
function generateNodePositions(size, width, height, padding, minDistance) {
  const positions = [];
  const maxAttempts = 1000;
  
  for (let i = 0; i < size; i++) {
    let attempts = 0;
    let validPosition = false;
    let x, y;
    
    while (!validPosition && attempts < maxAttempts) {
      x = padding + Math.random() * (width - 2 * padding);
      y = padding + Math.random() * (height - 2 * padding);
      
      // Check distance from all existing positions
      validPosition = true;
      for (let j = 0; j < positions.length; j++) {
        const dx = x - positions[j].x;
        const dy = y - positions[j].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < minDistance) {
          validPosition = false;
          break;
        }
      }
      
      attempts++;
    }
    
    positions.push({ x, y });
  }
  
  return positions;
}

// Generate random node positions if enabled
let sharedNodePositions = null;
if (RANDOM_NODE_POSITIONS) {
  const width = 380;
  const height = 380;
  const padding = 60;
  const minDistance = 80; // Minimum distance between nodes
  
  sharedNodePositions = generateNodePositions(MATRIX_SIZE, width, height, padding, minDistance);
}

// Display the matrix
document.getElementById("target").innerHTML = displayMatrix(correctMatrix, MATRIX_SIZE);

// Display graph type
document.getElementById("graphType").textContent = UNDIRECTED ? "Undirected Graph" : "Directed Graph";

// Update instruction text
document.getElementById("instructionText").textContent = UNDIRECTED 
  ? "Select the correct undirected graph visualization:" 
  : "Select the correct directed graph visualization:";

// Generate three options: one correct, two wrong (based on permutations)
const options = [
  { matrix: correctMatrix, isCorrect: true },
  { matrix: generateWrongMatrix(correctMatrix, MATRIX_SIZE), isCorrect: false },
  { matrix: generateWrongMatrix(correctMatrix, MATRIX_SIZE), isCorrect: false }
];

// Randomize the order
const shuffledOptions = options.sort(() => Math.random() - 0.5);

// Track selected option
let selectedOption = null;
let answered = false;

// Build choice cards with canvas graphs
const choicesDiv = document.getElementById("choices");
shuffledOptions.forEach((option, idx) => {
  const card = document.createElement("div");
  card.className = "option-card";
  card.dataset.index = idx;
  
  //const label = document.createElement("div");
  //label.className = "option-label";
  //label.textContent = "Option " + (idx + 1);
  
  const canvas = document.createElement("canvas");
  drawGraph(canvas, option.matrix, MATRIX_SIZE, sharedNodePositions);
  
  const selectBtn = document.createElement("div");
  selectBtn.className = "select-overlaygraph";
  selectBtn.textContent = "Select This";
  selectBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    selectOption(idx, card);
  });
  
  card.appendChild(canvas);
  //card.appendChild(label);
  card.appendChild(selectBtn);
  
  choicesDiv.appendChild(card);
});

// Select option function
function selectOption(idx, card) {
  if (answered) return;
  
  document.querySelectorAll(".option-card").forEach(c => c.classList.remove("selected"));
  card.classList.add("selected");
  selectedOption = idx;
  document.getElementById("submitBtn").disabled = false;
}

// Submit answer function
function submitAnswer() {
  if (selectedOption === null || answered) return;
  answered = true;
  
  const feedback = document.getElementById("feedback");
  const allCards = document.querySelectorAll(".option-card");
  const selectedCard = document.querySelector(`.option-card[data-index="${selectedOption}"]`);
  const isCorrect = shuffledOptions[selectedOption].isCorrect;
  
  // Disable select overlays
  allCards.forEach(card => {
    const overlay = card.querySelector(".select-overlaygraph");
    overlay.style.pointerEvents = "none";
    overlay.style.opacity = "0.5";
  });
  
  document.getElementById("submitBtn").disabled = true;
  
  if (isCorrect) {
    selectedCard.classList.add("correct");
    feedback.textContent = "✅ Correct!";
    feedback.style.color = "#4caf50";
  } else {
    selectedCard.classList.add("incorrect");
    allCards.forEach((card, idx) => {
      if (shuffledOptions[idx].isCorrect) {
        card.classList.add("correct");
      }
    });
    feedback.textContent = "❌ Wrong! The correct answer is highlighted in green.";
    feedback.style.color = "#f44336";
  }
  
  // Update score
  incrementScore(isCorrect);
   // show next
  document.getElementById("nextBtn").style.display = "inline-block";
}

/* expose functions globally */
window.submitAnswer = submitAnswer;
window.locationReload = () => location.reload();
window.selectOption = selectOption;
window.resetScore = resetScore;
setupNextButton('nextBtn');
</script>

</body>
</html>