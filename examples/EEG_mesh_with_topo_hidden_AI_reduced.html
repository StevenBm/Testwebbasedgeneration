<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>4D Meshes - EEG topography</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      header {
        display: none;
      }
      #container {
        width: 100vw;
        height: 100vh;
      }
      .page-wrapper {
        width: 100%;
        height: 100%;
      }
      .row {
        display: flex;
        width: 100%;
        height: 100%;
      }
      .column {
        flex: 1;
        height: 100%;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <noscript>
      <strong>niivue doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <header>
      <h3>Investigate the effect of single brain sources on the EEG voltage map</h3>
      <p>EEG electrodes are represented as yellow spheres, the voltage map is colour coded (red: positive values, blue: negative values).<br>
      'Brain' source slider enables you to change the source location (if clicked, key arrows work as well),
      'Gamma' slider enables you to change the contrast, radio button X, Y and Z permits to change the orientation of the dipole source.</p>
      <div class='row'>
        <div style="outline: #505050 2px solid; padding: 2px 10px;">
          <label for="meshXRay">XRay</label>
          <input type="range" min="0" max="10" value="3" class="slider" id="meshXRay" />
        </div>
        <div style="outline: #505050 2px solid; padding: 2px 10px;">
          <label for="meshMinSlider">Min threshold</label>
          <input type="range" min="0" max="1000" value="0" class="slider" id="meshMinSlider" />
        </div>
        <div style="outline: #505050 2px solid; padding: 2px 10px;">
          <label for="meshMaxSlider">Max threshold</label>
          <input type="range" min="0" max="1000" value="1000" class="slider" id="meshMaxSlider" />
        </div>
        <div style="outline: #505050 2px solid; padding: 2px 10px;">
          <label for="gammaSlider">Gamma</label>
          <input type="range" min="10" max="400" value="100" class="slider" id="gammaSlider" />
        </div>
        <div style="outline: #505050 2px solid; padding: 2px 10px;">
          <label for="normLeadfield">Normalised Leadfield</label>
          <input type="checkbox" id="normLeadfield" checked />
        </div>
      </div>
      <div class='row'>
        <div style="outline: #505050 2px solid; padding: 2px 10px;">
          Source orientation:
          <label for="oriX">X</label>
          <input type="radio" id="oriX" name="sourceOri" checked>
          <label for="oriY">Y</label>
          <input type="radio" id="oriY" name="sourceOri">
          <label for="oriZ">Z</label>
          <input type="radio" id="oriZ" name="sourceOri">
          <label for="oriCust" style="border-left: 2px solid grey; padding-left: 10px">custom:</label>
          <input type="radio" id="oriCust" name="sourceOri">
          <label for="aziSlider">azimuth</label>
          <input type="range" min="0" max="100" value="0" class="slider" disabled="true" id="aziSlider"/>
          <label for="elevSlider">elevation</label>
          <input type="range" min="0" max="100" value="0" class="slider" disabled="true" id="elevSlider"/>
        </div>
      </div>
      <label for="srcSlider">Brain source</label>
      <button id="prevSource">previous</button>
      <input type="range" min="0" max="1156" value="0" class="slider" style="width:50%" id="srcSlider" />
      <button id="nextSource">next</button>
    </header>
    <main id="container">
      <div class='page-wrapper'>
        <div class='row'>
          <div class='column'>
            <canvas id="gl1"></canvas>
          </div>
          <div class='column' style="pointer-events: none">
            <canvas id="gl2"></canvas>
          </div>
        </div>
      </div>
    </main>
  </body>
</html>
<script type="module">
  import * as niivue from "https://cdn.jsdelivr.net/npm/@niivue/niivue@0.46.0/dist/index.js";
  
  // Cache DOM elements
  const elements = {
    srcSlider: document.getElementById("srcSlider"),
    minSlider: document.getElementById("meshMinSlider"),
    maxSlider: document.getElementById("meshMaxSlider"),
    aziSlider: document.getElementById("aziSlider"),
    eleSlider: document.getElementById("elevSlider"),
    xBtn: document.getElementById('oriX'),
    yBtn: document.getElementById('oriY'),
    zBtn: document.getElementById('oriZ'),
    custBtn: document.getElementById('oriCust'),
    meshXRay: document.getElementById('meshXRay'),
    normLeadfield: document.getElementById('normLeadfield'),
    gamSlider: document.getElementById("gammaSlider"),
    prevSource: document.getElementById('prevSource'),
    nextSource: document.getElementById('nextSource')
  };
  
  // Parse URL parameters once
  const urlParams = new URLSearchParams(window.location.search);
  const srcnmbr = parseFloat(urlParams.get('srcnmbr')) || 0;
  const elevation = parseFloat(urlParams.get('elevation')) || 0;
  const azimuth = parseFloat(urlParams.get('azimuth')) || 0;

  // Set custom button based on URL params
 
    elements.custBtn.checked = true;

  // Constants
  const nElec = 208;
  const R = 10;
  const TWO_PI = 2 * Math.PI;
  
  // State variables
  let layIdx = 0;
  let azi = 0;
  let elev = 0;
  let nv1, nv2;
  let srcPos;
  let currSrcPos;
  let nFrame4D;
  
  // Fetch source positions
  async function fetchSourcePositions() {
    const response = await fetch("https://roehrin.github.io/webapps_for_EEG_courses/src/source_points.jcon");
    return response.json();
  }
  
  // Update crosshair position
  function updateCrosshairPos() {
    const dPos = nv1.mm2frac(currSrcPos);
    nv1.scene.crosshairPos = dPos;
    nv1.createOnLocationChange();
    nv1.drawScene();
  }
  
  // Calculate offset based on orientation
  function calculateOffset() {
    if (!elements.custBtn.checked) {
      return [R * elements.xBtn.checked, R * elements.yBtn.checked, R * elements.zBtn.checked];
    }
    return [
      R * Math.cos(elev) * Math.cos(azi),
      R * Math.cos(elev) * Math.sin(azi),
      R * Math.sin(elev)
    ];
  }
  
  // Update source visualization
  function updateSource() {
    const oriIdx = 1 * elements.yBtn.checked + 2 * elements.zBtn.checked;
    currSrcPos = [
      srcPos.nodes.X[5 * srcnmbr], 
      srcPos.nodes.Y[5 * srcnmbr], 
      srcPos.nodes.Z[5 * srcnmbr]
    ];
    updateCrosshairPos();
    
    const offset = calculateOffset();
    
    if (!elements.custBtn.checked) {
      const frameIdx = 3 * srcnmbr + oriIdx;
      nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "frame4D", frameIdx);
      nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "frame4D", frameIdx);
    } else {
      updateCustomOrientation(offset);
    }
  }
  
  // Update custom orientation
  function updateCustomOrientation(offset) {
    const values = nv1.meshes[0].layers[1].values;
    const startIdx = 3 * srcnmbr * nElec;
    
    const currTopoX = values.slice(startIdx, startIdx + nElec);
    const currTopoY = values.slice(startIdx + nElec, startIdx + 2 * nElec);
    const currTopoZ = values.slice(startIdx + 2 * nElec, startIdx + 3 * nElec);
    
    const normOffset = offset.map(o => o / R);
    const newTopo = currTopoX.map((num, idx) => 
      normOffset[0] * num + normOffset[1] * currTopoY[idx] + normOffset[2] * currTopoZ[idx]
    );
    
    const frameOffset = nFrame4D * nElec;
    nv1.meshes[0].layers[1].values.set(newTopo, frameOffset);
    nv2.meshes[0].layers[1].values.set(newTopo, frameOffset);
    
    const maxV = Math.max(...newTopo.map(Math.abs));
    const normTopo = newTopo.map(v => 90 * v / maxV);
    
    nv1.meshes[0].layers[0].values.set(normTopo, frameOffset);
    nv2.meshes[0].layers[0].values.set(normTopo, frameOffset);
    
    nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "frame4D", nFrame4D + 1);
    nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "frame4D", nFrame4D + 1);
  }
  
  // Set up event listeners
  function setupEventListeners() {
    elements.meshXRay.oninput = function() {
      nv1.opts.meshXRay = this.value * 0.1;
      const isVisible = this.value !== "0";
      nv1.opts.show3Dcrosshair = isVisible;
      // Note: No meshes[2] in this version (dipole commented out)
      nv1.drawScene();
    };
    
    elements.aziSlider.oninput = function() {
      if (!elements.custBtn.checked) return;
      azi = TWO_PI * 0.01 * this.value;
      updateSource();
    };
    
    elements.eleSlider.oninput = function() {
      if (!elements.custBtn.checked) return;
      elev = TWO_PI * 0.01 * this.value;
      updateSource();
    };
    
    const toggleCustom = (enable) => {
      elements.eleSlider.disabled = !enable;
      elements.aziSlider.disabled = !enable;
      updateSource();
    };
    
    elements.custBtn.onclick = () => toggleCustom(true);
    elements.xBtn.onclick = () => toggleCustom(false);
    elements.yBtn.onclick = () => toggleCustom(false);
    elements.zBtn.onclick = () => toggleCustom(false);
    
    elements.minSlider.oninput = function() {
      const val = this.value * 0.1;
      nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "cal_min", val);
      nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "cal_min", val);
    };
    
    elements.maxSlider.oninput = function() {
      const val = this.value * 0.1;
      nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "cal_max", val);
      nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "cal_max", val);
    };
    
    elements.srcSlider.oninput = updateSource;
    
    elements.normLeadfield.onclick = function() {
      layIdx = 1 * !elements.normLeadfield.checked;
      nv2.meshes[0].layers[0].colorbarVisible = elements.normLeadfield.checked;
      nv2.meshes[0].layers[1].colorbarVisible = !elements.normLeadfield.checked;
      nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "opacity", elements.normLeadfield.checked);
      nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "opacity", elements.normLeadfield.checked);
      nv1.setMeshLayerProperty(nv1.meshes[0].id, 1, "opacity", !elements.normLeadfield.checked);
      nv2.setMeshLayerProperty(nv2.meshes[0].id, 1, "opacity", !elements.normLeadfield.checked);
      elements.minSlider.oninput();
      elements.maxSlider.oninput();
      updateSource();
    };
    
    elements.gamSlider.oninput = function() {
      const gamma = this.value * 0.01;
      nv1.setGamma(gamma);
      nv2.setGamma(gamma);
      nv1.setMeshProperty(0, "edgeMin", 0);
      nv2.setMeshProperty(0, "edgeMin", 0);
    };
    
    elements.prevSource.onclick = () => {
      elements.srcSlider.value = String(elements.srcSlider.valueAsNumber - 1);
      updateSource();
    };
    
    elements.nextSource.onclick = () => {
      elements.srcSlider.value = String(elements.srcSlider.valueAsNumber + 1);
      updateSource();
    };
  }
  
  // Initialize visualization
  async function initialize() {
    // Fetch data
    srcPos = await fetchSourcePositions();
    currSrcPos = [srcPos.nodes.X[0], srcPos.nodes.Y[0], srcPos.nodes.Z[0]];
    
    // Mesh layers configuration
    const meshLayersList = [
      {
        url: "https://roehrin.github.io/webapps_for_EEG_courses/src/norm_leadfield.gii",
        colormap: "hot",
        colormapNegative: "electric_blue",
        cal_min: 0,
        cal_max: 100,
        useNegativeCmap: true,
        opacity: 1,
      },
      {
        url: "https://roehrin.github.io/webapps_for_EEG_courses/src/leadfield.gii",
        colormap: "hot",
        colormapNegative: "electric_blue",
        cal_min: 0,
        cal_max: 100,
        useNegativeCmap: true,
        opacity: 0,
      }
    ];
    
    // Initialize first viewer
    nv1 = new niivue.Niivue({
      show3Dcrosshair: false,
      isColorbar: false,
      showLegend: false,
      backColor: [0.9, 0.9, 1, 1],
      meshXRay: 0.5,
      isOrientCube: true,
      dragAndDropEnabled: false,
    });
    nv1.setSliceType(nv1.sliceTypeRender);
    nv1.attachTo("gl1");
    
    // Load meshes for nv1
    await nv1.loadMeshes([
      {
        url: "https://roehrin.github.io/webapps_for_EEG_courses/src/leadfield.gii",
        layers: meshLayersList,
      },
      {
        url: "https://roehrin.github.io/webapps_for_EEG_courses/src/EGI257_electrodes.jcon",
      },
    ]);
    
    nv1.drawScene();
    nv1.setMeshShader(nv1.meshes[0].id, "Diffuse");
    updateCrosshairPos();
    nv1.setRenderAzimuthElevation(0, 90);
    
    // Initialize second viewer
    nv2 = new niivue.Niivue({
      show3Dcrosshair: false,
      dragAndDropEnabled: false,
      isColorbar: false,
      showLegend: false,
      backColor: [0.9, 0.9, 1, 1],
      meshXRay: 0,
      isOrientCube: false,
    });
    nv2.attachTo("gl2");
    
    await nv2.loadMeshes([
      {
        url: "https://roehrin.github.io/webapps_for_EEG_courses/src/leadfield2D.gii",
        layers: meshLayersList,
      },
      {
        url: "https://roehrin.github.io/webapps_for_EEG_courses/src/EGI257_2Dlayout.jcon",
      }
    ]);
    
    nv2.setMeshShader(nv2.meshes[0].id, "Diffuse");
    nv2.setMeshProperty(nv2.meshes[1].id, "nodeScale", 1);
    nv2.meshes[1].colorbarVisible = false;
    nv2.meshes[0].layers[1].colorbarVisible = false;
    nv2.setRenderAzimuthElevation(0, 90);
    
    // Add custom frame for orientation
    nFrame4D = nv1.meshes[0].layers[0].nFrame4D;
    nv1.meshes[0].layers[0].nFrame4D = nFrame4D + 1;
    nv2.meshes[0].layers[0].nFrame4D = nFrame4D + 1;
    nv1.meshes[0].layers[1].nFrame4D = nFrame4D + 1;
    nv2.meshes[0].layers[1].nFrame4D = nFrame4D + 1;
    
    const currNormV = nv1.meshes[0].layers[0].values;
    const currV = nv1.meshes[0].layers[1].values;
    const newNormV = new Float32Array(currNormV.length + nElec);
    const newV = new Float32Array(currNormV.length + nElec);
    newNormV.set(currNormV, 0);
    newV.set(currV, 0);
    nv1.meshes[0].layers[0].values = newNormV;
    nv1.meshes[0].layers[1].values = newV;
    nv2.meshes[0].layers[0].values = newNormV;
    nv2.meshes[0].layers[1].values = newV;
    
    // Set up event listeners
    setupEventListeners();
    
    // Initial update with URL parameters
    elements.srcSlider.value = srcnmbr;
    elements.aziSlider.value = azimuth;
    elements.eleSlider.value = elevation;
    
    nv2.updateGLVolume();
    elements.aziSlider.oninput();
	elements.eleSlider.oninput();
  }
  
  // Start initialization
  initialize();
</script>