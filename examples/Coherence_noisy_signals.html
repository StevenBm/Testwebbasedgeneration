<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coherence-based connectivity</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0px;
        }
        .slider {
            margin: 10px 0;
        }
		.banner {
		  position: sticky;
		  top: 0;
		  background:#96004B;
		  color: #f1f1f1;
		  z-index: 1;
		  text-align: right;
		  padding: 10px
		}
		.divfooter {
		  top: 0;
		  background: #555;
		  color: #f1f1f1;
		}
		.text {
		  text-align: right;
		}
		.div {
		  margin: 20px;
		}
		section {
			margin: 30px;
		}
		h1 {
			margin: 10px;
		}
    </style>
</head>
<body>
	<div class="banner">
			<img src="https://www.unige.ch/cdn/themes/unige2016/img/unige-logo.svg">
			<br>&copy; 2025 Dr Nicolas Roehri
	</div>
	<h1>Coherence-based connectivity</h1>
	<section>
	<h2>Introduction</h2>
	<h3>Definition</h3>
	Coherence is a measure of functional connectivity between two signals based on the consistency of their phase and amplitude relationships across time or trials. It is commonly used in neuroscience and signal processing to analyse oscillatory interactions between brain regions, usually using EEG, MEG or LFP signals.
	<h3>Key concept</h3>
	Two signals are considered to be coherent if they maintain a consistent phase relationship across a specific frequency range while also exhibiting correlated amplitude fluctuations. This means that not only do their oscillations stay phase-locked to some degree, but their power dynamics are also related. This suggests a functional interaction between the underlying sources that generate these signals.
	</section>
	<section>
	<h2>Example: Computing the Coherence (Coh)</h2>
	Let us assume two noisy oscillating signals \(S_1\) and \(S_2\) of amplitudes \(A_1\) and \(A_2\), frequencies \(f_1\) and \(f_2\), and phase shifts \(\theta_1\) and \(\theta_2\), respectively. These signals are written as:
	$$S_1(t) = A_1(t)\cos(2\pi f_1t + \theta_1) + \epsilon_1(t), and$$ $$S_2(t) = A_2(t)\cos(2\pi f_2t + \theta_2) + \epsilon_2(t)$$ $$\epsilon_i \sim \mathcal{N}(0,\sigma^{2}).$$
	\(f_1\), \(\theta_1\) are fixed, \(f_1 = 10\textrm{ Hz}, \theta_1=0\textrm{ rad}\), \(t\) is the time. <br>
	\(f_2\), \(\theta_2\) and \(\sigma\) are user defined.
	</section>
	<section>
	As for the \(\text{PLV}\), we need to estimate a phase, but this time we also need an amplitude. Here we will again use the instantaneous phase given by their analytic signal (\(\widehat{S_1}\) and \(\widehat{S_2}\)). Note, however, that the coherence is generally presented as a spectral measure obtained with the phase of the Fourier transform. Both implementation are valid, but it highly depends on the context. Thanks to the Hilbert transform (\(\mathcal{H}(.)\)) and <a href="https://en.wikipedia.org/wiki/Euler's_formula" target="_blank" rel="noopener noreferrer">Euler's formula</a>, we obtain:
	$$\widehat{S_1}(t)= S_1(t)+i\mathcal{H}(S_1(t)) = A(t)e^{i(2\pi f_1t + \theta_1)} + \widehat{\epsilon_1}(t),$$
	$$\widehat{S_2}(t)= A(t)e^{i(2\pi f_2t + \theta_2)} + \widehat{\epsilon_2}(t).$$
	The instantaneous phase is defined as:
	$$\phi_i(t)= 2\pi f_it + \theta_i,$$
	$$\textrm{so }\widehat{S_i}(t)= A_i(t)e^{i\phi_i(t)} + \widehat{\epsilon_i}(t),$$
	as \(\widehat{\epsilon_i}\) is also a complex, we can write again thanks to Euler's formula:
	$$\widehat{S_i}(t)= \tilde{A}(t)e^{i\tilde{\phi_i}(t)}$$
	where \(\tilde{A}\) and \(\tilde{\phi_i}\) are the (noisy) estimation of \(A\) and \(\phi_i\). In other word, when the noise becomes null, \(\lim_{\sigma\to0} \tilde{A} = A\) and \(\lim_{\sigma\to0} \tilde{\phi_i} = \phi_i\).
	For simplicity of the notation we will only use \(A\)  and \(\phi_i\).
	<br>
	The Coherence (Coh) measures the consistency of both phase and power correlations between two signals, ranging from 0 (no synchrony) to 1 (perfect synchrony)(<a href="https://doi.org/10.1016/S0013-4694(97)00066-7" target="_blank" rel="noopener noreferrer">Nunez et al., 1997</a>).
	$$\text{Coh}(S_1,S_2) = \frac{\left| \sum_{t=1}^{N} \widehat{S_1}(t) \widehat{S_2}^{*}(t) \right|}{\sqrt{\sum_{t=1}^{N} \left| \widehat{S_1}(t) \right|^2 \sum_{t=1}^{N} \left| \widehat{S_2}(t) \right|^2}}$$
	$$\text{Coh}(S_1,S_2) = \frac{\left| \sum_{t=1}^{N} A_1(t)e^{i\phi_1(t)} A_2(t)e^{-i\phi_2(t)} \right|}{\sqrt{\sum_{t=1}^{N} A_1^2(t) \sum_{t=1}^{N} A_2^2(t)}}$$
	$$\text{Coh}(S_1,S_2) = \frac{\left| \sum_{t=1}^{N} A_1(t)A_2(t)e^{i\Delta\phi_{1,2}(t)} \right|}{\sqrt{\sum_{t=1}^{N} A_1^2(t) \sum_{t=1}^{N} A_2^2(t)}}$$<br>
	\(N\) is the total number of time points, \(\Delta\phi_{1,2}\) the phase difference, and \(\left| . \right|\)the absolute value. From the definition it is clear that the coherence is symmetrical or undirected, i.e. \(\text{Coh}(S_1,S_2) = \text{Coh}(S_2,S_1)\).<br>
	$$\Phi_{\text{Coh}}(S_1,S_2) = \arg \left( \frac{ \sum_{t=1}^{N} A_1(t)A_2^*(t)e^{i\Delta\phi_{1,2}(t)}}{\sqrt{\sum_{t=1}^{N} A_1^2(t) \sum_{t=1}^{N} A_2^2(t)}} \right)$$
	\(\arg(.)\) is the argument function, which gives the phase angle of the complex mean phase difference.<br>
	\(\Phi_{\text{Coh}}\) represents the preferred phase difference. Note that \(\Phi_{\text{Coh}}(S_1,S_2) = -\Phi_{\text{Coh}}(S_2,S_1)\)<br>
	One can represent both information as a phasor, using the complex valued coherence (before applying \(\left| . \right|\)) in a polar plot, where its radius would be the \(\text{Coh}\) and \(\Phi_{\text{Coh}}\) its angle.
	$$\mathcal{P}_{\text{Coh}}(S_1,S_2) = \frac{\sum_{t=1}^{N} A_1(t)A_2(t)e^{i\Delta\phi_{1,2}(t)} }{\sqrt{\sum_{t=1}^{N} A_1^2(t) \sum_{t=1}^{N} A_2^2(t)}}$$
	<br>
	<h3>Case 1: constant amplitude</h3>
	As a first example, let us define \(A_1=A_2=A=1\).
	The plot below let you modify \(f_2\), \(\theta_2\) and \(\sigma\) and see their effect on the \(\text{Coh}\).<br>
	First, you could test that when \(\sigma = 0\), \(\Phi_{\text{Coh}} = - \theta_2\) whatever the value of \(\theta_2\) and \(\text{Coh} = 1\).
	When you change \(f_2\), \(\text{Coh}\) tends to zero, since the two signals are not phase consistent anymore.
	</section>
    <div id="plot" style="width:100%;height:600px;"></div>
	<div class="divfooter" id="myDivFooter">
		<span style="padding: 5px">
			<label for="frequency">\(f_2\) :</label>
			<input type="range" id="frequency" class="slider" min="1" max="25" value="10">
			<span id="freqValue">10 Hz</span>
		</span>
		<span style="padding: 5px">
			<label for="phase">\(\theta_2\) :</label>
			<input type="range" id="phase" class="slider" min="-175" max="180" value="0" step="5">
			<span id="phaseValue">0 rad</span>
		</span>
		<span style="padding: 5px">
			<label for="noiseLevel">\(\sigma\) :</label>
			<input type="range" id="noiseLevel" class="slider" min="0" max="1" value="0.1" step="0.01">
			<span id="noiseValue">0.10</span>
		</span>
		<span style="padding: 5px">
		Show: 
		<input type="checkbox" id="showCoh" checked /><label for="showCoh">Coh</label>
		<input type="checkbox" id="showimCoh"/><label for="showimCoh">imCoh</label>
		<input type="checkbox" id="showcimCoh"/><label for="showcimCoh">cimCoh</label>
		</span>
		<span style="padding: 5px">
		Cases: 
		<input type="radio" id="case1Btn" name="caseID" checked>
		<label for="case1Lbl">case 1</label>
		<input type="radio" id="case2Btn" name="caseID">
		<label for="case2Lbl"> case 2</label>
		</span>
    </div>
	<section>
	<h3>Case 2: amplitude modulated signal</h3>
	Let us now investigate the coherence metric when the amplitude is not constant, but varies over time.
	$$A_1(t) = \frac{1}{2}(m\cos(2\pi f_{A_1}t + \theta_{A_1}) + 1)$$ 
	\(f_{A_1}\) the frequency of the cosine amplitude modulation, \(\theta_{A_1}\) the phase shift of the cosine amplitude modulation and \(m\) the  amplitude of modulation. Let us set \(f_{A_1} = 2\textrm{ Hz}\), \(\theta_{A_1} = 0\textrm{ rad}\) and \(m = \frac{4}{5}\).<br>
	<br>
	Note that now when \(\sigma = 0\), \(\text{Coh} \neq 1\). This is because, even though the signals still have a consistent phase difference over time, their amplitude variations are not consistent anymore.<br>
	<br>
	Something strange happens when \(f_{2} = 8\textrm{ Hz}\) or \(f_{2} = 12\textrm{ Hz}\). For these frequencies, \(\text{Coh} \neq 0\) even if \(f_{1} \neq f_{2}\). Do you know why?<br>
	<button onclick="answerDisp()">Answer</button><div id="answerDiv" style="padding: 5px; display: none">Using trigonometric identities, we write \(S_1\) as a sum of three cosine waves:
	$$S_1(t) = \frac{1}{2}(m\cos(2\pi f_{A_1}t + \theta_{A_1}) + 1)\cos(2\pi f_1t + \theta_1)$$
	$$S_1(t) = \frac{1}{2}\cos(2\pi f_1t + \theta_1) + \frac{1}{2}m\cos(2\pi f_{A_1}t + \theta_{A_1})\cos(2\pi f_1t + \theta_1)$$
	$$S_1(t) = \frac{1}{2}\cos(2\pi f_1t + \theta_1) + \frac{1}{4}m\cos(2\pi (f_1 - f_{A_1})t + \theta_1 - \theta_{A_1}) + \frac{1}{4}m\cos(2\pi (f_1 + f_{A_1})t + \theta_1 + \theta_{A_1})$$ 
	the carrier wave (\(S_1\) from case 1) which is unchanged in frequency (\(f_1\)), and two sidebands with frequencies slightly above and below the carrier frequency \(f_1\), i.e. \(f_{sb} = f_1 \pm f_{A_1} = 10 \pm 2\textrm{ Hz}\).
	</div>
	</section>
	<section>
	<h3>Case 3: TODO</h3>
	</section>
	<section>
	<h2>Version of the Coherence robust to spatial leakage.</h2>
	In case of spatial leakage (signal mixing), such in Electrical Source Imaging, \(S_1\) and \(S_2\) can be spuriously correlated. However, this spurious correlation is instantaneous and thus occurs at 0-lag. One way to compensate for that is by removing the contribution to the 0-lag in the computation of the Coh. Importantly, 0-lag means that the phase difference equals 0. Any contribution at 0-lag happens on the real axis. Therefore the imaginary part of the Coh \(\text{imCoh}\) is defined as (<a href="https://doi.org/10.1016/j.clinph.2004.04.029" target="_blank" rel="noopener noreferrer">Nolte et al., 2004</a>):
	$$\text{imCoh} = \left|\Im\left( \mathcal{P}_{\text{Coh}} \right)\right|$$<br>
	\(\Im\) is the imaginary part. 
	This metric is now robust to spurious 0-lag but also removes any genuine 0-lag. We cannot, however, estimate the true preferred phase due to the mixing. Intuitively, \(\text{imCoh}\) is the projection of the \(\text{Coh}\) phasor onto the imaginary axis. Check the \(\text{imCoh}\) box, and see how this metric behaves according to different changes in phase and noise.
	<br>
	<br>
	Unfortunately, \(\text{imCoh}\) is sensitive to the preferred phase difference \(\Phi_{\text{Coh}}\). A corrected version of \(\text{imCoh}\), named corrected imCoh (<a href="https://doi.org/10.1098/rsta.2011.0081" target="_blank" rel="noopener noreferrer">Pascual-Marqui et al., 2011</a>), mitigates this effect and is defined as:
	$$\text{cimCoh} = \frac{\Im\left( \mathcal{P}_{\text{Coh}}\right)}{\sqrt{1-\Re\left( \mathcal{P}_{\text{Coh}} \right)^2}}$$<br>
	\(\Re\) is the real part.<br>
	Check the \(\text{cimCoh}\) box, and see how this metric behaves according to different changes in phase and noise.
	</section>
	<script>
	function answerDisp() {
		  var x = document.getElementById("answerDiv");
		  if (x.style.display === "none") {
			x.style.display = "block";
		  } else {
			x.style.display = "none";
		  }
		}
	</script>
    <script type="module" async>
		import {computeDFT, generateGaussianNoise, generateSineWave, analyticSignal, computeCoherence, computecImCoh, computeImCoh} from 'https://roehrin.github.io/webapps_for_EEG_courses/js-scripts/simpleSignalProcessing.js';
        
		const checkboxes = document.querySelectorAll('input[type=checkbox]');
		const radiobuttons = document.querySelectorAll('input[type=radio]');
		
        const sampleRate = 256;
		const freq1 = 10;
		const phase1 = 0;
		var freq2 = parseFloat(document.getElementById("frequency").value);
		var phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
		var noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
        const time = Array.from({ length: 2*sampleRate }, (_, i) => i / sampleRate);
		const N = time.length;
		const envFreq = 2;
		const metricColours = ['orange', 'green', 'purple'];
		
		var w1 = .65;
		var w2 = .25;
		var w3 = .05;
		var wgap = .05;
		// normalise the ws to ensure the sum equals 1
		let wnorm = w1 + w2 + w3 + 2*wgap;
		w1 = w1/wnorm; w2 = w2/wnorm; wgap = wgap/wnorm;
		
        
		// Generate noise
		var noise1 = generateGaussianNoise(noiseLvl, time.length); // Noise for first channel
		var noise2 = generateGaussianNoise(noiseLvl, time.length); // Second sine wave
		
		// Generate sine waves
		var sineWave1 = generateSineWave(time, freq1, phase1, noise1); // First sine wave
		var sineWave2 = generateSineWave(time, freq2, phase2, noise2); // Second sine wave
		
		// compute analytic signal
		var zWave1 = analyticSignal(sineWave1); // First sine wave
		var zWave2 = analyticSignal(sineWave2); // Second sine wave
		
		
		function computeSampleCoh(zWave1, zWave2) {
			// compute power
			const power1 = zWave1.reduce((sum, [re, im]) => sum + (re ** 2 + im ** 2), 0); // First sine wave
			const power2 = zWave2.reduce((sum, [re, im]) => sum + (re ** 2 + im ** 2), 0); // Second sine wave
			
			let sampleMagn = zWave1.map(([real, imag]) => N*(real ** 2 + imag ** 2)/Math.sqrt(power1 * power2));				
			let samplePhase = zWave1.map(([real, imag], i) => Math.atan2(imag * zWave2[i][0] - real * zWave2[i][1], real * zWave2[i][0] + imag * zWave2[i][1] ));
			
			return {sampleMagn, samplePhase};
		}
		
		frequency.oninput = function () {
			freq2 = parseFloat(document.getElementById("frequency").value);
			document.getElementById("freqValue").textContent = freq2 + " Hz";
			sineWave2 = generateSineWave(time, freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			updatePlots()
		}
		
		phase.oninput = function () {
			phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
			document.getElementById("phaseValue").textContent = phase2.toFixed(2) + " rad";
			sineWave2 = generateSineWave(time, freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			updatePlots()
		}
		
		noiseLevel.oninput = function () {
			noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
			document.getElementById("noiseValue").textContent = noiseLvl.toFixed(2);
			
			noise1 = generateGaussianNoise(noiseLvl, time.length);
			sineWave1 = generateSineWave(time, freq1, phase1, noise1, case2Btn.checked*envFreq);
			zWave1 = analyticSignal(sineWave1);
			
			noise2 = generateGaussianNoise(noiseLvl, time.length);
			sineWave2 = generateSineWave(time, freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			updatePlots()
		}

        function updatePlots() {        
            
			const sampleCoh = computeSampleCoh(zWave1, zWave2);
			const Coh = computeCoherence(zWave1, zWave2)
			const imCoh = computeImCoh(Coh);
			const cimCoh = computecImCoh(Coh)
			// compute envelop
			const envp1 = zWave1.map(([real, imag]) => Math.sqrt(real ** 2 + imag ** 2));
			const envp2 = zWave2.map(([real, imag]) => Math.sqrt(real ** 2 + imag ** 2)); 
			// conpute instantaneous phase
			const instPhase1 = zWave1.map(([real, imag]) => Math.atan2(imag, real)); // Math.atan2(imag, real))
			const instPhase2 = zWave2.map(([real, imag]) => Math.atan2(imag, real));
			// to compute the angle diff we have to pass again to the complex values to stay within [-pi, pi]
			const angleDiff = instPhase1.map((ph1, i) => Math.atan2(Math.sin(ph1-instPhase2[i]),Math.cos(ph1-instPhase2[i]))); 
			
            // Create traces for time domain signals
            const timeTrace1 = {
                x: time,
                y: sineWave1,
                mode: 'lines',
				type: 'scatter',
                name: '$S_1(t)$',
                line: { color: 'black' }
            };

            const timeTrace2 = {
                x: time,
                y: sineWave2,
                mode: 'lines',
                name: '$S_2(t)$',
				type: 'scatter',
                line: { color: 'blue',dash: 'dashdot'}
            };
			
			const timeEnv1 = {
                x: time,
                y: envp1,
                mode: 'lines',
                name: '$A_1(t)$',
				type: 'scatter',
                line: { color: 'black', dash: 'dashdot', width: 2},
				visible: 'legendonly'
            };
			const timeEnv2 = {
                x: time,
                y: envp2,
                mode: 'lines',
                name: '$A_2(t)$',
				type: 'scatter',
                line: { color: 'blue', dash: 'dash', width: 2},
				visible: 'legendonly'
            };

			// Create traces for instantaneous phase signals
            const instPhTrace1 = {
                x: time,
                y: instPhase1,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
				type: 'scatter',
                name: '$\\phi_1(t)$',
                line: { color: 'black' },
				showlegend: true,
            };

            const instPhTrace2 = {
                x: time,
                y: instPhase2,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
                name: '$\\phi_2(t)$',
				type: 'scatter',
                line: { color: 'blue',dash: 'dashdot'},
				showlegend: true,
            };
			
			const instPhDiffTrace = {
                x: time,
                y: angleDiff,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
                name: '$\\Delta\\phi(t)$',
				type: 'scatter',
                line: { color: 'brown', dash: 'solid', width:2},
				showlegend: true,
            };

            // Create scatter plot trace
            const scatterTrace = {
				type: "scatterpolar",
				r: sampleCoh.sampleMagn,
				theta: sampleCoh.samplePhase,
				mode: "markers",
				marker: {
					color: 'brown',//"#2255ff",
					size: 10,
					line: {
					  color: "white"
					},
					opacity: 0.1
				},
				thetaunit: "radians",
				cliponaxis: true,
				subplot: "polar",
				name: "sample coh.",
			};
			
			// Create bar plot for correlation
			const CohPlot = [{
				type: "scatterpolar",
				name: `Coh (r = ${Coh.magnitude.toFixed(2)}, ang. = ${Coh.preferredPhase.toFixed(2)} rad)`,
				r: [0, Coh.magnitude],
				theta: [0, Coh.preferredPhase],
				marker: {
					color: "orange",
					symbol: "square",
					size: [0, 15],
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showCoh.checked,
			},
			{
				type: "scatterpolar",
				name: `imCoh (r = ${imCoh.magnitude.toFixed(2)})`,
				r: [0, imCoh.magnitude],
				theta: [0, imCoh.preferredPhase],
				marker: {
					color: "green",
					symbol: 121,
					line: {
						width: 3
					},
					size: [0, 15],
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",				
				visible: showimCoh.checked,
			},
			{
				type: "scatterpolar",
				name: `cimCoh (r = ${cimCoh.magnitude.toFixed(2)})`,
				r: [0, cimCoh.magnitude],
				theta: [0, cimCoh.preferredPhase],
				marker: {
					color: "purple",
					symbol: 121,
					line: {
						width: 3
					},
					size: [0, 15],
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showcimCoh.checked,
			}
			];
			
			// Define metric data
			const metricsData = {
				Coh: Coh.magnitude,
				imCoh: imCoh.magnitude,
				cimCoh: cimCoh.magnitude
			};
			
			var barValues = [];
			var barText = [];
			var barColors = [];
			
			checkboxes.forEach(checkbox => {
				if (checkbox.checked) {
					barValues.push(metricsData[checkbox.id.substr(4)]);  // Store metric name
					barText.push(checkbox.id.substr(4)); // Store corresponding values
					let ind = ['Coh', 'imCoh', 'cimCoh'].indexOf(checkbox.id.substr(4));
					barColors.push(metricColours[ind])
				}
			});
			
			// Create bar plot for correlation
			const barPlot = {
				x: barText,
				y: barValues,
				type: 'bar',
				xaxis: 'x3',
				yaxis: 'y3',
				name: 'Bar Plot',
				marker:{
					color: barColors
				},
				showlegend: false
			};
			
            // Define subplots layout
            const layout = {
                //grid: { rows: subplotRows, columns: subplotCols, pattern: 'independent' },
				// time domain
                xaxis: { domain: [0, w1], anchor: 'y1', matches: 'x2'},
                yaxis: { title: 'Amplitude (V)', domain: [.55, 1], anchor: 'x1', range: [-1.5, 1.5]},
				// inst phase axis
				xaxis2: { title: 'Time (s)', domain: [0, w1], anchor: 'y2'},
                yaxis2: { title: 'Phase (rad)', domain: [0, .45], anchor: 'x2', range: [-Math.PI, Math.PI], 
							tickmode: "array", tickvals: [-Math.PI, -1/2*Math.PI, 0, 1/2*Math.PI, Math.PI],
							ticktext: ['-π', '-<sup>1</sup>⁄<sub>2</sub>π','0','<sup>1</sup>⁄<sub>2</sub>π','π']
						},
				// bar plot
				xaxis3: { domain: [w1+w2+wgap, 1], anchor: 'y3'},
                yaxis3: { title: 'Magnitude', domain: [0, 1], side: 'right', anchor: 'x3', range: [0, 1]},
				
				// polar scatter
				polar: {domain: {x: [w1+wgap, w1+w2], y: [0, 1]}, angularaxis: {thetaunit: "radians"}, radialaxis: {range: [0, 2]}},
				showlegend: true,
				font: { size: 16 },
				legend: {x: 0, xanchor: 'left', y: 1.1, orientation: "h", font: { size: 16 }}
            };

            // Combine all traces into a single data array
            var combinedData = [
                timeTrace1,
                timeTrace2,
				timeEnv1,
				timeEnv2,
				instPhTrace1,
                instPhTrace2,
				instPhDiffTrace,
				scatterTrace,
				barPlot,
            ];
			combinedData = combinedData.concat(CohPlot);

            // Update the plot
            Plotly.newPlot('plot', combinedData, layout, {responsive: true});
        }

        // Initial plot
        updatePlots();
		
		checkboxes.forEach(checkbox => {
            checkbox.addEventListener('click', updatePlots);
        });
		
		radiobuttons.forEach(checkbox => {
            checkbox.addEventListener('click', noiseLevel.oninput);
        });

    </script>
</body>
</html>
