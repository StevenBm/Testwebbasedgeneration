
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>4D Meshes - EEG topography</title>
	<link rel="stylesheet" href="../niivue_dualview.css" />
  </head>
  <body>
    <noscript>
      <strong
        >niivue doesn't work properly without JavaScript enabled. Please enable
        it to continue.</strong
      >
    </noscript>
    <header>
	<h3>Investigate the effect of single brain sources on the EEG voltage map</h3>
	<p>EEG electrodes are represented as yellow spheres, the voltage map is colour coded (red: positive values, blue: negative values).<br>
	'Brain' source slider enables you to change the source location (if clicked, key arrows wors as well),
	'Gamma' slider enables you to change the contrast, radio button X, Y and Z permits to change the orientation of the dipole source.</p>
		<div class='row'>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="meshXRay">XRay</label>
			<input type="range" min="0" max="10" value="3" class="slider" id="meshXRay" />
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="meshMinSlider">Min threshold</label>
			<input
				type="range"
				min="0"
				max="1000"
				value="0"
				class="slider"
				id="meshMinSlider"
			/>
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="meshMaxSlider">Max threshold</label>
			<input
				type="range"
				min="0"
				max="1000"
				value="1000"
				class="slider"
				id="meshMaxSlider"
			/>
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="gammaSlider">Gamma</label>
			<input
				type="range"
				min="10"
				max="400"
				value="100"
				class="slider"
				id="gammaSlider"
			/>
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="normLeadfield">Normalised Leadfield</label>
			<input type="checkbox" id="normLeadfield" checked />
			</div>
		</div>
		<div class='row'>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			Source orientation:
				<label for="oriXbtn">X</label>
				<input type="radio" id="oriX" name="sourceOri" checked>
				<label for="oriYbtn">Y</label>
				<input type="radio" id="oriY" name="sourceOri">
				<label for="oriZbtn">Z</label>
				<input type="radio" id="oriZ" name="sourceOri">
				<label for="oriCust" style="border-left: 2px solid grey; padding-left: 10px">custom:</label>
				<input type="radio" id="oriCust" name="sourceOri">
				<label for="aziSlider">azimuth</label>
				<input type="range"	min="0" max="100" value="0" class="slider" disabled="true" id="aziSlider"/>
				<label for="elevSlider">elevation</label>
				<input type="range"	min="0" max="100" value="0" class="slider" disabled="true" id="elevSlider"/>
			</div>
		</div>
		<label for="srcSlider">Brain source</label>
		<button id="prevSource">previous</button>
		<input
			type="range"
			min="0"
			max="1156"
			value="0"
			class="slider"
			style="width:50%"
			id="srcSlider"
		/>
		<button id="nextSource">next</button>
</header>
    <main id="container">
	<div class='page-wrapper'>
        <div class='row'>
          <div class='column'>
              <canvas id="gl1">
          </div>
          <div class='column' style="pointer-events: none">
              <canvas id="gl2">
          </div>
        </div>
    </div>
    </main>
  </body>
</html>
<script type="module" async>
  import * as niivue from "https://cdn.jsdelivr.net/npm/@niivue/niivue@0.46.0/dist/index.js";
  
  var srcSlider = document.getElementById("srcSlider");
  var minSlider = document.getElementById("meshMinSlider");
  var maxSlider = document.getElementById("meshMaxSlider");
  var aziSlider = document.getElementById("aziSlider");
  var eleSlider = document.getElementById("elevSlider");
  var xBtn = document.getElementById('oriX')
  var yBtn = document.getElementById('oriY')
  var zBtn = document.getElementById('oriZ')
  var custBtn = document.getElementById('oriCust')
  var nElec = 208;
  var layIdx = 0;
  var azi = 0; var elev = 0; const R = 10;// variable for the custom dipole orientation  
  const response = await fetch("https://roehrin.github.io/webapps_for_EEG_courses/src/source_points.jcon", {})
  const srcPos = await response.json()
  var currSrcPos = [srcPos.nodes.X[0], srcPos.nodes.Y[0], srcPos.nodes.Z[0]];
  function updateCrosshairPos(){
	let dPos = nv1.mm2frac(currSrcPos); // current position of the source, mm convert to frac
	nv1.scene.crosshairPos = dPos;
    nv1.createOnLocationChange()
    nv1.drawScene()
  }
  meshXRay.oninput = function () {
        nv1.opts.meshXRay = this.value * 0.1
		if (this.value === "0"){
			nv1.opts.show3Dcrosshair= false;
			nv1.meshes[2].visible= false;
		}
		else {
			nv1.opts.show3Dcrosshair= true;
			nv1.meshes[2].visible= true;
			}
        nv1.drawScene()
  }
  aziSlider.oninput = function () {
	if (!custBtn.checked){return;} // only rotate the dipole if custom orientation is checked
	azi = 2*Math.PI*0.01*this.value;
	srcSlider.oninput();
  }
  elevSlider.oninput = function () {
	if (!custBtn.checked){return;} // only rotate the dipole if custom orientation is checked
	elev = 2*Math.PI*0.01*this.value;
	srcSlider.oninput();
  }
  custBtn.onclick = function () {
	eleSlider.disabled = false;
	aziSlider.disabled = false;
	srcSlider.oninput();
  }
  xBtn.onclick = function () {
	eleSlider.disabled = true;
	aziSlider.disabled = true;
	srcSlider.oninput();
  };
  yBtn.onclick = function () {
	eleSlider.disabled = true;
	aziSlider.disabled = true;
	srcSlider.oninput();
  };
  zBtn.onclick = function () {
	eleSlider.disabled = true;
	aziSlider.disabled = true;
	srcSlider.oninput();
  };
  minSlider.oninput = function () {
    nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "cal_min", this.value * 0.1);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "cal_min", this.value * 0.1);
  };
  maxSlider.oninput = function () {
    nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "cal_max", this.value * 0.1);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "cal_max", this.value * 0.1);
  };
  srcSlider.oninput = function () {
	let oriIdx = 1*yBtn.checked + 2*zBtn.checked;
	// leadfield.gii contains 1 every 5 sources, hence the 5*
	currSrcPos = [srcPos.nodes.X[5*this.value], srcPos.nodes.Y[5*this.value], srcPos.nodes.Z[5*this.value]];
	updateCrosshairPos()
	let offset = [0, 0, 0];
	// handle position and orientation of the dipole
	if (!custBtn.checked){
		offset = [R*xBtn.checked, R*yBtn.checked, R*zBtn.checked];
	} else {
		offset = [R*Math.cos(elev)*Math.cos(azi), R*Math.cos(elev)*Math.sin(azi), R*Math.sin(elev)];
	}
	nv1.meshes[2].nodes = [
      {
        name: "source",
        x: currSrcPos[0],
        y: currSrcPos[1],
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 5
      },
      {
        name: "target",
        x: currSrcPos[0]+offset[0],
        y: currSrcPos[1]+offset[1],
        z: currSrcPos[2]+offset[2],
        colorValue: 1,
        sizeValue: 2.5
      }
    ];
	nv1.meshes[2].updateMesh(nv1.gl)
	if (!custBtn.checked){
		nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "frame4D", 3*(this.value)+oriIdx);
		nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "frame4D", 3*(this.value)+oriIdx);
	} else {
		// get raw lead field values
		let values = nv1.meshes[0].layers[1].values;
		// slice(start, end)
		let currTopoX = values.slice(3*this.value*nElec,3*this.value*nElec + nElec);
		let currTopoY = values.slice(3*this.value*nElec+nElec,3*this.value*nElec+2*nElec);
		let currTopoZ = values.slice(3*this.value*nElec+2*nElec,3*this.value*nElec+3*nElec);
		// compute the new topography;
		offset = offset.map(function (o) {return o/R});
		currTopoX = currTopoX.map(function (num, idx) {return offset[0]*num + offset[1]*currTopoY[idx] + offset[2]*currTopoZ[idx]});
		// store the new topo in last frame of the raw leadfield
		nv1.meshes[0].layers[1].values.set(currTopoX,nFrame4D*nElec);
		nv2.meshes[0].layers[1].values.set(currTopoX,nFrame4D*nElec);
		// normalised and  store the new topo in last frame of the normalised leadfield
		let maxV = Math.max(...currTopoX.map(Math.abs)); // max is set at 90/100
		currTopoX = currTopoX.map(function (v) {return 90*v/maxV});
		nv1.meshes[0].layers[0].values.set(currTopoX,nFrame4D*nElec);
		nv2.meshes[0].layers[0].values.set(currTopoX,nFrame4D*nElec);
		nv1.setMeshLayerProperty(nv1.meshes[0].id, layIdx, "frame4D", nFrame4D+1);
		nv2.setMeshLayerProperty(nv2.meshes[0].id, layIdx, "frame4D", nFrame4D+1);
	}
  };
  normLeadfield.onclick = async function() {
	layIdx = 1*!normLeadfield.checked;
	nv2.meshes[0].layers[0].colorbarVisible = normLeadfield.checked;
	nv2.meshes[0].layers[1].colorbarVisible = !normLeadfield.checked;
	nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "opacity", normLeadfield.checked);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "opacity", normLeadfield.checked);
	nv1.setMeshLayerProperty(nv1.meshes[0].id, 1, "opacity", !normLeadfield.checked);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 1, "opacity", !normLeadfield.checked);
	minSlider.oninput();
	maxSlider.oninput();
	srcSlider.oninput();
	}
  var gamSlider = document.getElementById("gammaSlider");
  gamSlider.oninput = function () {
	
    nv1.setGamma(this.value * 0.01);
	nv2.setGamma(this.value * 0.01);
	nv1.setMeshProperty(0, "edgeMin", 0) // little trick to update the mesh otherwise only the volume is updated
	nv2.setMeshProperty(0, "edgeMin", 0)
  };
  var nv1 = new niivue.Niivue({
    show3Dcrosshair: true,
	isColorbar: false,
	showLegend: false,
    backColor: [0.9, 0.9, 1, 1],
	meshXRay: .5,
	isOrientCube: true,
	dragAndDropEnabled: false,
  });
  nv1.setSliceType(nv1.sliceTypeRender);
  nv1.attachTo("gl1");
  var meshLayersList = [
    {
      url: "https://roehrin.github.io/webapps_for_EEG_courses/src/norm_leadfield.gii",
	  colormap: "hot",
	  colormapNegative: "electric_blue",
	  cal_min: 0,
      cal_max: 100,
      useNegativeCmap: true,
      opacity: 1,
    },
	{
      url: "https://roehrin.github.io/webapps_for_EEG_courses/src/leadfield.gii",
	  colormap: "hot",
	  colormapNegative: "electric_blue",
	  cal_min: 0,
      cal_max: 100,
      useNegativeCmap: true,
      opacity: 0,
    }
  ];
  // draw dipole using connectome variable
  var dipole = {name: "dipole",
    nodeColormap: "hot",
    nodeColormapNegative: "",
    nodeMinColor: 0,
    nodeMaxColor: 1,
    nodeScale: 1, //scale factor for node, e.g. if 2 and a node has size 3, a 6mm ball is drawn
    edgeColormap: "hot",
    edgeColormapNegative: "",
    edgeMin: 0,
    edgeMax: 2.5,
    edgeScale: 1,
    legendLineThickness: 0,
    nodes: [
      {
        name: "source",
        x: currSrcPos[0],
        y: currSrcPos[1],
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 5
      },
      {
        name: "target",
        x: currSrcPos[0]+R,
        y: currSrcPos[1],
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 2.5
      }
    ],
    edges: [{
      first: 0,
      second: 1,
      colorValue: 2.5
    }],
  }   //dipole{}
  //await nv1.loadVolumes(volumeList1);
  await nv1.loadMeshes([
    {
      url: "https://roehrin.github.io/webapps_for_EEG_courses/src/leadfield.gii",
	  layers: meshLayersList,
    },
	{
      url: "https://roehrin.github.io/webapps_for_EEG_courses/src/EGI257_electrodes.jcon",
    },
  ]);
  
  //await nv1.loadConnectome(dipole)
  nv1.addMesh(nv1.loadConnectomeAsMesh(dipole))
  nv1.drawScene()
  nv1.setMeshShader(nv1.meshes[0].id, "Diffuse");
  updateCrosshairPos()
  nv1.setRenderAzimuthElevation(0, 90);
  var nv2 = new niivue.Niivue({
    show3Dcrosshair: false,
	dragAndDropEnabled: false,
	isColorbar: true,
	showLegend: false,
    backColor: [0.9, 0.9, 1, 1],
	meshXRay: 0,
	isOrientCube: false,
  });
  nv2.attachTo("gl2");
  await nv2.loadMeshes([
    {
	  url: "https://roehrin.github.io/webapps_for_EEG_courses/src/leadfield2D.gii",
	  layers: meshLayersList,
    },
	{
	  url: "https://roehrin.github.io/webapps_for_EEG_courses/src/EGI257_2Dlayout.jcon",
    }
  ]);
  nv2.setMeshShader(nv2.meshes[0].id, "Diffuse");
  nv2.setMeshProperty(nv2.meshes[1].id, "nodeScale", 1)
  nv2.meshes[1].colorbarVisible = false;
  nv2.meshes[0].layers[1].colorbarVisible = false;
  nv2.setRenderAzimuthElevation(0, 90);
  // add one frame to store the custom orientation, computed on the fly
  const nFrame4D = nv1.meshes[0].layers[0].nFrame4D;
  nv1.meshes[0].layers[0].nFrame4D = nFrame4D+1;
  nv2.meshes[0].layers[0].nFrame4D = nFrame4D+1;
  nv1.meshes[0].layers[1].nFrame4D = nFrame4D+1;
  nv2.meshes[0].layers[1].nFrame4D = nFrame4D+1;
  let currNormV = nv1.meshes[0].layers[0].values;
  let currV = nv1.meshes[0].layers[1].values;
  let newNormV = new Float32Array(currNormV.length + nElec)
  let newV = new Float32Array(currNormV.length + nElec)
  newNormV.set(currNormV,0);
  newV.set(currV,0);
  nv1.meshes[0].layers[0].values = newNormV;	
  nv1.meshes[0].layers[1].values = newV;	
  nv2.meshes[0].layers[0].values = newNormV;	
  nv2.meshes[0].layers[1].values = newV;	
  //normLeadfield.onclick();
  prevSource.onclick = function () {
		srcSlider.value = String(srcSlider.valueAsNumber-1);
		srcSlider.oninput();
	}
	nextSource.onclick = function () {
		srcSlider.value = String(srcSlider.valueAsNumber+1);
		srcSlider.oninput();
	}
	nv2.updateGLVolume()
</script>
