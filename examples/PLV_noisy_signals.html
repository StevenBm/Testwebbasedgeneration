<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase-based connectivity</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0px;
        }
        .slider {
            margin: 10px 0;
        }
		.banner {
		  position: sticky;
		  top: 0;
		  background:#96004B;
		  color: #f1f1f1;
		  z-index: 1;
		  text-align: right;
		  padding: 10px
		}
		.divfooter {
		  top: 0;
		  background: #555;
		  color: #f1f1f1;
		}
		.text {
		  text-align: right;
		}
		.div {
		  margin: 20px;
		}
		section {
			margin: 30px;
		}
		h1 {
			margin: 10px;
		}
    </style>
</head>
<body>
	<div class="banner">
			<img src="https://www.unige.ch/cdn/themes/unige2016/img/unige-logo.svg">
			<br>&copy; 2025 Dr Nicolas Roehri
	</div>
	<h1>Phase-based connectivity</h1>
	<p>
	<section>
	<h2>Introduction</h2>
	<h3>Definition</h3>
	Phase-based connectivity is a measure of the functional connectivity between two signals based on the synchronisation of their instantaneous phase dynamics rather than their amplitude or power. It is commonly used in neuroscience and signal processing to analyse oscillatory interactions between brain regions, usually using EEG, MEG or LFP signals.
	<h3>Key concept</h3>
	Two signals are considered to be phase-coupled if their instantaneous phase differences remain coherent over time, even if their amplitudes fluctuate. This suggests a functional interaction between the underlying sources that generate these signals.
	</section>
	<section>
	<h2>Example: Computing the Phase-Locking Value (PLV)</h2>
	Let us assume two noisy oscillating signals \(S_1\) and \(S_2\) of amplitudes \(A_1\) and \(A_2\), frequencies \(f_1\) and \(f_2\), and phase shifts \(\theta_1\) and \(\theta_2\), respectively. These signals are written as:
	$$S_1(t) = A_1(t)\cos(2\pi f_1t + \theta_1) + \epsilon_1(t), and$$ $$S_2(t) = A_2(t)\cos(2\pi f_2t + \theta_2) + \epsilon_2(t)$$ $$\epsilon_i \sim \mathcal{N}(0,\sigma^{2}).$$
	\(f_1\), \(\theta_1\) and \(A\) are fixed, \(f_1 = 10\textrm{ Hz}, \theta_1=0\textrm{ rad}, A=1\), \(t\) is the time. <br>
	\(f_2\), \(\theta_2\) and \(\sigma\) are user defined.
	</section>
	<section>
	To compute phased-based connectivity metric between \(S_1\) and \(S_2\), we need to estimate a phase. Here we will use the instantaneous phase given by their analytic signal (\(\widehat{S_1}\) and \(\widehat{S_2}\)). Thanks to the Hilbert transform (\(\mathcal{H}(.)\)) and <a href="https://en.wikipedia.org/wiki/Euler's_formula" target="_blank" rel="noopener noreferrer">Euler's formula</a>, we obtain:
	$$\widehat{S_1}(t)= S_1(t)+i\mathcal{H}(S_1(t)) = Ae^{i(2\pi f_1t + \theta_1)} + \widehat{\epsilon_1}(t),$$
	$$\widehat{S_2}(t)= Ae^{i(2\pi f_2t + \theta_2)} + \widehat{\epsilon_2}(t).$$
	The instantaneous phase is defined as:
	$$\phi_i(t)= 2\pi f_it + \theta_i,$$
	$$\textrm{so }\widehat{S_1}(t)= Ae^{i\phi_1(t)} + \widehat{\epsilon_1}(t), \textrm{ and } \widehat{S_2}(t)= Ae^{i\phi_2(t)} + \widehat{\epsilon_2}(t),$$
	as \(\widehat{\epsilon_i}\) is also a complex, we can write again thanks to Euler's formula:
	$$\widehat{S_i}(t)= \tilde{A}e^{i\tilde{\phi_i}(t)}$$
	where \(\tilde{A}\) and \(\tilde{\phi_i}\) are the (noisy) estimation of \(A\) and \(\phi_i\). In other word, when the noise becomes null, \(\\lim_{\sigma\to0} \tilde{A} = A\) and \(\\lim_{\sigma\to0} \tilde{\phi_i} = \phi_i\).
	For simplicity of the notation we will only use \(A\)  and \(\phi_i\).
	<p>	
	The Phase Locking Value (PLV) is a measure of phase synchrony between two signals, independent of the amplitude of the signal (<a href=" https://doi.org/10.1002/(SICI)1097-0193(1999)8:4<194::AID-HBM4>3.0.CO;2-C" target="_blank" rel="noopener noreferrer">Lachaux et al., 1999</a>).
	$$\text{PLV}(S_1,S_2) = \left| \frac{1}{N} \sum_{t=1}^{N} e^{i (\phi_1(t) - \phi_2(t))} \right|$$
	$$\text{or, PLV}(S_1,S_2) = \left| \frac{1}{N} \sum_{t=1}^{N} e^{i \Delta\phi_{1,2}(t)} \right|$$<br>
	\(N\) is the total number of time points, \(\Delta\phi_{1,2}\) the phase difference, and \(\left| . \right|\)the absolute value. From the definition it is clear that the coherence is symmetrical or undirected, i.e. \(\text{PLV}(S_1,S_2) = \text{PLV}(S_2,S_1)\)<br>
	This measure quantifies how consistent the phase difference between two signals is over time, ranging from 0 (no phase synchrony) to 1 (perfect synchrony). Noteworthy, \(A\) is not used in the defition of the \(\text{PLV}\) rendering this metric independent of the amplitude. Beware, that it is still dependent on the signal-to-noise ratio, but not the amplitude of the signal per se.
	$$\Phi_{\text{PLV}}(S_1,S_2) = \arg \left( \frac{1}{N} \sum_{t=1}^{N} e^{i \Delta\phi_{1,2}(t)} \right)$$
	\(\arg(.)\) is the argument function, which gives the phase angle of the complex mean phase difference.<br>
	\(\Phi_{\text{PLV}}\) represents the preferred phase difference. Note that \(\Phi_{\text{PLV}}(S_1,S_2) = -\Phi_{\text{PLV}}(S_2,S_1)\)<br>
	One can represent both information as a phasor in a polar plot, where its radius would be the \(\text{PLV}\) and \(\Phi_{\text{PLV}}\) its angle, that is:
	$$\mathcal{P}_{\text{PLV}}(S_1,S_2) = \frac{1}{N} \sum_{t=1}^{N} e^{i \Delta\phi_{1,2}(t)} = \text{PLV}e^{i \Phi_{\text{PLV}}}$$	
	<p>
	<h3>Case 1: constant amplitude</h3>
	As a first example, let us define \(A_1=A_2=A=1\).
	The plot below let you modify \(f_2\), \(\theta_2\) and \(\sigma\) and see their effect on the \(\text{PLV}\).<br>
	First, you could test that when \(\sigma = 0\) and \(f_1 = f_2\), \(\Phi_{\text{PLV}} = \theta_1 - \theta_2 = - \theta_2\) whatever the value of \(\theta_2\) and \(\text{PLV} = 1\).
	</section>
    <div id="plot" style="width:100%;height:600px;"></div>
	<div class="divfooter" id="myDivFooter">
		<span style="padding: 5px">
			<label for="frequency">\(f_2\) :</label>
			<input type="range" id="frequency" class="slider" min="1" max="25" value="10">
			<span id="freqValue">10 Hz</span>
		</span>
		<span style="padding: 5px">
			<label for="phase">\(\theta_2\) :</label>
			<input type="range" id="phase" class="slider" min="-175" max="180" value="0" step="5">
			<span id="phaseValue">0 rad</span>
		</span>
		<span style="padding: 5px">
			<label for="noiseLevel">\(\sigma\) :</label>
			<input type="range" id="noiseLevel" class="slider" min="0" max="1" value="0.1" step="0.01">
			<span id="noiseValue">0.1</span>
		</span>
		<span style="padding: 5px">
		Show: 
		<input type="checkbox" id="showPLV" checked /><label for="showPLV">PLV</label>
		<input type="checkbox" id="showiPLV"/><label for="showiPLV">iPLV</label>
		<input type="checkbox" id="showciPLV"/><label for="showciPLV">ciPLV</label>
		</span>
		<span style="padding: 5px">
		Cases: 
		<input type="radio" id="case1Btn" name="caseID" checked>
		<label for="case1Lbl">case 1</label>
		<input type="radio" id="case2Btn" name="caseID">
		<label for="case2Lbl"> case 2</label>
		</span>
    </div>
	<section>
	<h3>Case 2: amplitude modulated signal</h3>
	Let us now investigate the PLV metric when the amplitude is not constant, but varies over time.
	$$A_1(t) = \frac{1}{2}(a\cos(2\pi f_{A_1}t + \theta_{A_1}) + 1)$$ 
	\(f_{A_1}\) the frequency of the cosine amplitude modulation, \(\theta_{A_1}\) the phase shift of the cosine amplitude modulation and \(a\) the amount of modulation. Let us set \(f_{A_1} = 2\textrm{ Hz}\), \(\theta_{A_1} = 0\textrm{ rad}\) and \(a = \frac{4}{5}\).<br>
	<br>
	Interestingly, when \(\sigma = 0\), \(\text{PLV} = 1\), even if the amplitude/envelope of signal 1 is not constant anymore. This is because the computation of the \(\text{PLV}\) does not take the amplitude into account (and because the envelope is never 0 in our case, otherwise the phase could not be determine correctly).<br>
	<br>
	If \(\sigma \ne 0\), one can see that the \(\text{PLV}\) from case 2 is lower than the \(\text{PLV}\) from case 1 for the same amount of noise. This is due to the fact that at the trough of the envelope, the level of is relatively high compared to the amplitude of the signal. The instantaneous phase become more dependent to the noise than to the signal of interest. This is why, even though the \(\text{PLV}\) is not sensitive to the amplitude it is sensitive to the signal to noise ratio.
	</section>
	<section>
	<h2>Version of the Phase Locking Value robust to spatial leakage.</h2>
	In case of spatial leakage (signal mixing), such in Electrical Source Imaging, \(S_1\) and \(S_2\) can be spuriously correlated. However, this spurious correlation is instantaneous and thus occurs at 0-lag. One way to compensate for that is by removing the contribution to the 0-lag in the computation of the PLV. Importantly, 0-lag means that the phase difference equals 0. Any contribution at 0-lag happens on the real axis. Therefore the imaginary part of the PLV (\(\text{iPLV}\)) is defined as (<a href="https://doi.org/10.1088/1741-2552/aacfe4" target="_blank" rel="noopener noreferrer">Bru√±a et al., 2018</a>):
	$$\text{iPLV} = \left|\Im\left( \mathcal{P}_{\text{PLV}} \right)\right|$$<br>
	\(\Im\) is the imaginary part. 
	This metric is now robust to spurious 0-lag but also removes any genuine 0-lag. We cannot, however, estimate the true preferred phase due to the mixing. Intuitively, \(\text{iPLV}\) is the projection of the \(\text{PLV}\) phasor onto the imaginary axis. Check the \(\text{iPLV}\) box, and see how this metric behaves according to different changes in phase and noise.
	<br>
	<br>
	Unfortunately, \(\text{iPLV}\) is sensitive to the preferred phase difference \(\Phi_{\text{PLV}}\). A corrected version of \(\text{iPLV}\), named corrected iPLV, mitigates this effect and is defined as (<a href="https://doi.org/10.1088/1741-2552/aacfe4" target="_blank" rel="noopener noreferrer">Bru√±a et al., 2018</a>):
	$$\text{ciPLV} = \frac{\Im\left( \mathcal{P}_{\text{PLV}}\right)}{\sqrt{1-\Re\left( \mathcal{P}_{\text{PLV}} \right)^2}}$$<br>
	\(\Re\) is the real part.<br>
	Check the \(\text{ciPLV}\) box, and see how this metric behaves according to different changes in phase and noise.
	</section>
	
	
    <script type="module" async>
		import {computeDFT, generateGaussianNoise, generateSineWave, analyticSignal, computePLV, computeiPLV, computeciPLV} from 'https://roehrin.github.io/webapps_for_EEG_courses/js-scripts/simpleSignalProcessing.js';
        
		const checkboxes = document.querySelectorAll('input[type=checkbox]');
		const radiobuttons = document.querySelectorAll('input[type=radio]');
		
        const sampleRate = 256;
		const freq1 = 10;
		const phase1 = 0;
		var freq2 = parseFloat(document.getElementById("frequency").value);
		var phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
		var noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
        const time = Array.from({ length: 2*sampleRate }, (_, i) => i / sampleRate);
		const envFreq = 2;
		const metricColours = ['orange', 'green', 'purple'];
		
		var w1 = .65;
		var w2 = .25;
		var w3 = .05;
		var wgap = .05;
		// normalise the ws to ensure the sum equals 1
		let wnorm = w1 + w2 + w3 + 2*wgap;
		w1 = w1/wnorm; w2 = w2/wnorm; wgap = wgap/wnorm;
		
        
		// Generate noise
		var noise1 = generateGaussianNoise(noiseLvl, time.length); // Noise for first channel
		var noise2 = generateGaussianNoise(noiseLvl, time.length); // Second sine wave
		
		// Generate sine waves
		var sineWave1 = generateSineWave(time, freq1, phase1, noise1); // First sine wave
		var sineWave2 = generateSineWave(time, freq2, phase2, noise2); // Second sine wave
		
		// compute analytic signal
		var zWave1 = analyticSignal(sineWave1); // First sine wave
		var zWave2 = analyticSignal(sineWave2); // Second sine wave
		
		var instPhase1 = zWave1.map(([real, imag]) => Math.atan2(imag, real)); // Math.atan2(imag, real))
		var instPhase2 = zWave2.map(([real, imag]) => Math.atan2(imag, real));
		
		frequency.oninput = function () {
			freq2 = parseFloat(document.getElementById("frequency").value);
			document.getElementById("freqValue").textContent = freq2 + " Hz";
			sineWave2 = generateSineWave(time, freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			instPhase2 = zWave2.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			updatePlots()
		}
		
		phase.oninput = function () {
			phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
			document.getElementById("phaseValue").textContent = phase2.toFixed(2) + " rad";
			sineWave2 = generateSineWave(time, freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			instPhase2 = zWave2.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			updatePlots()
		}
		
		noiseLevel.oninput = function () {
			noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
			document.getElementById("noiseValue").textContent = noiseLvl.toFixed(2);
			
			noise1 = generateGaussianNoise(noiseLvl, time.length);
			sineWave1 = generateSineWave(time, freq1, phase1, noise1, case2Btn.checked*envFreq);
			zWave1 = analyticSignal(sineWave1);
			instPhase1 = zWave1.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			
			noise2 = generateGaussianNoise(noiseLvl, time.length);
			sineWave2 = generateSineWave(time, freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			instPhase2 = zWave2.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			updatePlots()
		}
		

        function updatePlots() {        
            
			const PLV = computePLV(instPhase1, instPhase2);
			const iPLV = computeiPLV(PLV);
			const ciPLV = computeciPLV(PLV)
			// to compute the angle diff we have to pass again to the complex values to stay within [-pi, pi]
			const angleDiff = instPhase1.map((ph1, i) => Math.atan2(Math.sin(ph1-instPhase2[i]),Math.cos(ph1-instPhase2[i]))); 
            // Create traces for time domain signals
            const timeTrace1 = {
                x: time,
                y: sineWave1,
                mode: 'lines',
				type: 'scatter',
                name: '$S_1(t)$',
                line: { color: 'black' }
            };

            const timeTrace2 = {
                x: time,
                y: sineWave2,
                mode: 'lines',
                name: '$S_2(t)$',
				type: 'scatter',
                line: { color: 'blue',dash: 'dashdot'}
            };
			
			// Create traces for instantaneous phase signals
            const instPhTrace1 = {
                x: time,
                y: instPhase1,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
				type: 'scatter',
                name: '$\\phi_1(t)$',
                line: { color: 'black' },
				showlegend: true,
            };

            const instPhTrace2 = {
                x: time,
                y: instPhase2,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
                name: '$\\phi_2(t)$',
				type: 'scatter',
                line: { color: 'blue',dash: 'dashdot'},
				showlegend: true,
            };
			
			const instPhDiffTrace = {
                x: time,
                y: angleDiff,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
                name: '$\\Delta\\phi_{1,2}(t)$',
				type: 'scatter',
                line: { color: 'brown',dash: 'solid'},
				showlegend: true,
            };


            // Create scatter plot trace
            const scatterTrace = {
				type: "scatterpolar",
				r: new Array(angleDiff.length).fill(1),
				theta: angleDiff,
				mode: "markers",
				marker: {
					color: 'brown',//"#2255ff",
					size: 10,
					line: {
					  color: "white"
					},
					opacity: 0.1
				},
				thetaunit: "radians",
				cliponaxis: true,
				subplot: "polar",
				name: '$\\Delta\\phi_{1,2}(t)$',
			};
			
			
			// Create bar plot for correlation
			const plvPlot = [{
				type: "scatterpolar",
				name: `PLV (PLV = ${PLV.magnitude.toFixed(2)}, ang. = ${PLV.phaseLocking.toFixed(2)} rad)`,
				r: [0, PLV.magnitude],
				theta: [0, PLV.phaseLocking],
				marker: {
					color: "orange",
					symbol: "square",
					size: [0, 15],
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showPLV.checked,
			},
			{
				type: "scatterpolar",
				name: `iPLV (r = ${iPLV.magnitude.toFixed(2)})`,
				r: [0, iPLV.magnitude],
				theta: [0, iPLV.phaseLocking],
				marker: {
					color: "green",
					symbol: 121,
					line: {
						width: 3
					},
					size: [0, 15],
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",				
				visible: showiPLV.checked,
			},
			{
				type: "scatterpolar",
				name: `ciPLV (r = ${ciPLV.magnitude.toFixed(2)})`,
				r: [0, ciPLV.magnitude],
				theta: [0, ciPLV.phaseLocking],
				marker: {
					color: "purple",
					symbol: 121,
					line: {
						width: 3
					},
					size: [0, 15],
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showciPLV.checked,
			}
			];
			
			// Define metric data
			const metricsData = {
				PLV: PLV.magnitude,
				iPLV: iPLV.magnitude,
				ciPLV: ciPLV.magnitude
			};
			
			var barValues = [];
			var barText = [];
			var barColors = [];
			
			checkboxes.forEach(checkbox => {
				if (checkbox.checked) {
					barValues.push(metricsData[checkbox.id.substr(4)]);  // Store metric name
					barText.push(checkbox.id.substr(4)); // Store corresponding values
					let ind = ['PLV', 'iPLV', 'ciPLV'].indexOf(checkbox.id.substr(4));
					barColors.push(metricColours[ind])
				}
			});
			
			// Create bar plot for correlation
			const barPlot = {
				x: barText,
				y: barValues,
				type: 'bar',
				xaxis: 'x3',
				yaxis: 'y3',
				name: 'Bar Plot',
				marker:{
					color: barColors
				},
				showlegend: false
			};
			
            // Define subplots layout
            const layout = {
                //grid: { rows: subplotRows, columns: subplotCols, pattern: 'independent' },
				// time domain
                xaxis: { domain: [0, w1], anchor: 'y1', matches: 'x2'},
                yaxis: { title: 'Amplitude (V)', domain: [.55, 1], anchor: 'x1', range: [-1.5, 1.5]},
				xaxis2: { title: 'Time (s)', domain: [0, w1], anchor: 'y2'},
                yaxis2: { title: 'Phase (rad)', domain: [0, .45], anchor: 'x2', range: [-Math.PI, Math.PI], 
							tickmode: "array", tickvals: [-Math.PI, -1/2*Math.PI, 0, 1/2*Math.PI, Math.PI],
							ticktext: ['-œÄ', '-<sup>1</sup>‚ÅÑ<sub>2</sub>œÄ','0','<sup>1</sup>‚ÅÑ<sub>2</sub>œÄ','œÄ']
						},				
				// bar plot
				xaxis3: { domain: [w1+w2+wgap, 1], anchor: 'y3'},
                yaxis3: { title: 'Magnitude', domain: [0, 1], side: 'right', anchor: 'x3', range: [0, 1]},
				
				// polar scatter
				polar: {domain: {x: [w1+wgap, w1+w2], y: [0, 1]}, angularaxis: {thetaunit: "radians"}, radialaxis: {range: [0, 1.1]}},
				showlegend: true,
				font: { size: 16 },
				legend: {x: 0, xanchor: 'left', y: 1.1, orientation: "h", font: { size: 16 }}
            };

            // Combine all traces into a single data array
            var combinedData = [
                timeTrace1,
                timeTrace2,
                instPhTrace1,
                instPhTrace2,
				instPhDiffTrace,
				scatterTrace,
				barPlot
            ];
			combinedData = combinedData.concat(plvPlot);

            // Update the plot
            Plotly.newPlot('plot', combinedData, layout, {responsive: true});
        }

        // Initial plot
        updatePlots();
		
		checkboxes.forEach(checkbox => {
            checkbox.addEventListener('click', updatePlots);
        });
		
		radiobuttons.forEach(checkbox => {
            checkbox.addEventListener('click', noiseLevel.oninput);
        });
				
    </script>
</body>
</html>
