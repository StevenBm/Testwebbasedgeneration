<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Interactive ROI Network</title>
    <link rel="stylesheet" href="../niivue_dualview.css" />
  </head>
  <body>
    <noscript>niivue requires JavaScript.</noscript>
    <header>
	<h3>Investigate the structural connectome</h3>
	<div class="dropdown">
		<button class="dropbtn" data-toggle="dropdown">
		  View
		  <i class="fa fa-caret-down"></i>
		</button>
		<div class="dropdown-content">
		  <a href="#" class="viewBtn" id="|Axial">Axial</a>
		  <a class="viewBtn" id="|Sagittal">Sagittal</a>
		  <a class="viewBtn" id="|Coronal">Coronal</a>
		  <a class="viewBtn" id="|Render">Render</a>
		  <a class="viewBtn" id="|MultiPlanar">A+C+S</a>
		  <a class="viewBtn dropdown-item-checked" id="|MultiPlanarRender">A+C+S+R</a>
		  <a class="viewBtn divider dropdown-item-checked" id="Colorbar">Colorbar</a>
		  <a class="viewBtn" id="Radiological">Radiological</a>
		  <a class="viewBtn" id="ClipPlane">Render Clip Plane</a>
		</div>
    </div>
	<div class="dropdown">
        <button class="dropbtn">
          Edge Color
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a class="viewBtn dropdown-item-checked" id="!EdPlasma">Plasma</a>
          <a class="viewBtn" id="!EdViridis">Viridis</a>
          <a class="viewBtn" id="!EdInferno">Inferno</a>
		  <a class="viewBtn" id="!EdRandom">Random</a>
        </div>
    </div>
	<div class="dropdown">
        <button class="dropbtn">
          Node Color
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a class="viewBtn dropdown-item-checked" id="!NdPlasma">Plasma</a>
          <a class="viewBtn" id="!NdViridis">Viridis</a>
          <a class="viewBtn" id="!NdInferno">Inferno</a>
		  <a class="viewBtn" id="!NdRandom">Random</a>
        </div>
    </div>
	<div class="dropdown">
        <button class="dropbtn">
          Network file
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a class="viewBtn dropdown-item-checked" id="_SC">fiber count and strength</a> 
          <a class="viewBtn" id="_SClog">log fiber count and strength</a> 
          <a class="viewBtn" id="_SCCC">fiber count and clustering coeff</a> 
          <a class="viewBtn" id="_SClogCC">log fiber count and clustering coeff</a> 
		  <a class="viewBtn" id="_SCNE">fiber count and nodal eff</a> 
          <a class="viewBtn" id="_SClogNE">log fiber count and nodal eff</a> 
        </div>
    </div>
  </header>
    <main id="container">
	<div class='page-wrapper'>
		<div class="row">
				<div style="width: 400px; background: #404040;">
				Select regions of interest: <br>
				(show: <input type="radio" id="showNd" name="subNeighb" value="showNode" checked>
			 	<label for="rbShow">node</label>
			  	<input type="radio" id="showNeigh" name="subNeighb" value="subNodeNeighb">
			  	<label for="rbNeighb">node neighbourhood</label>)<br>
				Right hemisphere:<br>
				<label id="rhROI_btns"></label><br>
				<p>
				Left hemisphere:<br>
				<label id="lhROI_btns"></label>
				</div>
			<div class="column">
				<canvas id="gl1"></canvas>
			</div>
		</div>
	</div>
    </main>
  <footer>
	<label for="edgeSlider">Edge Size</label>
    <input type="range" min="0" max="100" value="30" class="slider" id="edgeSlider" />
	<label for="EdThreshSlider">Edge Threshold</label>
    <input type="range" min="0" max="99" value="0" class="slider" id="EdThreshSlider" />
    <label for="nodeSlider">Node Size</label>
    <input type="range" min="0" max="150" value="30" class="slider" id="nodeSlider" />
    <label for="NdThreshSlider">Node Threshold</label>
    <input type="range" min="0" max="99" value="0" class="slider" id="NdThreshSlider" />
    <button id="reset">reset</button>
  </footer>
  </body>
</html>
<script type="module" async>
  import * as niivue from "https://cdn.jsdelivr.net/npm/@niivue/niivue@0.46.0/dist/index.js";
  var volumeList1 = [
    {
      url: "../src/mni152.nii.gz", 
      colormap: "gray",
      visible: true,
      opacity: 1
    }
  ];
  var fname = "../src/Lausanne2_ROI_n_SC.jcon"
  function toggleGroup(id) {
    let buttons = document.getElementsByClassName("viewBtn");
    let char0 = id.charAt(0);
	let char03 = id.slice(0,3);
    for (let i = 0; i < buttons.length; i++) {
	  if (buttons[i].id.charAt(0) !== char0) continue;
	  if ((char03 === "!Ed" || char03 === "!Nd") && (buttons[i].id.slice(0,3) !== char03)) continue;
	  buttons[i].classList.remove("dropdown-item-checked");
	  if (buttons[i].id === id)
		buttons[i].classList.add("dropdown-item-checked");
    }
  } // toggleGroup()
  function updateMeshes() {
	// apply current threshold (setMeshProperty updates the volume every time it is called, slowers everything)
	//var startTime = performance.now()
	nv1.meshes[0].setProperty("edgeScale", edgeSlider.value*.1, nv1.gl)
	nv1.meshes[0].setProperty("nodeScale", nodeSlider.value*.1, nv1.gl)
	nv1.meshes[0].setProperty("nodeMinColor", NdThreshSlider.value * .01, nv1.gl)
	nv1.meshes[0].setProperty("edgeMin", EdThreshSlider.value * .01, nv1.gl)
	nv1.meshes[0].setProperty("edgeColormap", EdColormap, nv1.gl)
	nv1.meshes[0].setProperty("nodeColormap", NdColormap, nv1.gl)
	nv1.updateGLVolume()
	nv1.onMeshPropertyChanged(0, "edgeScale", edgeSlider.value*.1)
	nv1.onMeshPropertyChanged(0, "nodeScale", nodeSlider.value*.1)
	nv1.onMeshPropertyChanged(0, "nodeMinColor", NdThreshSlider.value * .01)
	nv1.onMeshPropertyChanged(0, "edgeMin", EdThreshSlider.value * .01)
	nv1.onMeshPropertyChanged(0, "edgeColormap", EdColormap)
	nv1.onMeshPropertyChanged(0, "nodeColormap", NdColormap)
	//var endTime = performance.now()
	//console.log(`Call to doSomething took ${endTime - startTime} milliseconds`)
  } // updateMeshes
  function showNeighbourhood(node_idx){
	console.log('sub network of node ' + node_idx + ' wanted, to be done.')
	nv1.meshes = []; // close any open mesh
	// deep copy of the original edges of the connectome
	let currentEdges = JSON.parse(JSON.stringify(nv1.origConnectome.edges));
	let ConnectedNodes = []; // init list of connected nodes
	let nodes = nv1.origConnectome.nodes;
	// set to zero all edges not connected to the node of interest
	for (let i = 0; i < currentEdges.length; i++) {
		// if edge is already zero continue
		if (currentEdges[i].colorValue === 0){ continue}
		if ((currentEdges[i].first != node_idx) && (currentEdges[i].second != node_idx) ){
			currentEdges[i].colorValue = 0;
			continue
		}
		// check if first correspond to the node of interest, if not add it otherwise add the second
		// (as it means the second is the node of interest)
		if (nodes[currentEdges[i].first].name != nodes[node_idx].name){
			ConnectedNodes.push(nodes[currentEdges[i].first].name);
		} else {ConnectedNodes.push(nodes[currentEdges[i].second].name);}
	}
	// deep copy of the original connectome to modify its edges
	let newConnectome = JSON.parse(JSON.stringify(nv1.origConnectome));
	newConnectome.edges = currentEdges;
	newConnectome.edgeColormapNegative = "";
	nv1.loadConnectome(newConnectome);
	updateMeshes()
	// set button colour to gray if not connected and blue otherwise
	let rhROI_btns = document.getElementById("rhROI_btns");
	for (let btnIdx=0; btnIdx < rhROI_btns.childNodes.length; btnIdx++){
		if (rhROI_btns.childNodes[btnIdx].innerHTML === nodes[node_idx].name){
			rhROI_btns.childNodes[btnIdx].style.backgroundColor ="#00AA00"
		} else if (ConnectedNodes.includes(rhROI_btns.childNodes[btnIdx].innerHTML)){
			rhROI_btns.childNodes[btnIdx].style.backgroundColor = "#880088"
		} else{rhROI_btns.childNodes[btnIdx].style.backgroundColor = ""}
	}
	let lhROI_btns = document.getElementById("lhROI_btns");
	for (let btnIdx=0; btnIdx < lhROI_btns.childNodes.length; btnIdx++){
		if (lhROI_btns.childNodes[btnIdx].innerHTML === nodes[node_idx].name){
			lhROI_btns.childNodes[btnIdx].style.backgroundColor ="#00AA00"
		} else if (ConnectedNodes.includes(lhROI_btns.childNodes[btnIdx].innerHTML)){
			lhROI_btns.childNodes[btnIdx].style.backgroundColor = "#880088"
		} else{lhROI_btns.childNodes[btnIdx].style.backgroundColor = ""}
	}
  }
  async function onButtonClick(event) {
	  if (event.target.id.charAt(0) === "|") {
		  //sliceType
		  if (event.target.id === "|Axial") nv1.setSliceType(nv1.sliceTypeAxial);
		  if (event.target.id === "|Coronal")
			nv1.setSliceType(nv1.sliceTypeCoronal);
		  if (event.target.id === "|Sagittal")
			nv1.setSliceType(nv1.sliceTypeSagittal);
		  if (event.target.id === "|Render") nv1.setSliceType(nv1.sliceTypeRender);
		  if (event.target.id === "|MultiPlanar") {
			nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.NEVER;
			nv1.setSliceType(nv1.sliceTypeMultiplanar);
		  }
		  if (event.target.id === "|MultiPlanarRender") {
			nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS;
			nv1.setSliceType(nv1.sliceTypeMultiplanar);
		  }
		  toggleGroup(event.target.id);
	  } //sliceType
	  if (event.target.id === "Colorbar") {
		  nv1.opts.isColorbar = !nv1.opts.isColorbar;
		  event.srcElement.classList.toggle("dropdown-item-checked");
		  nv1.drawScene();
		  return;
		}
	  if (event.target.id === "Radiological") {
		  nv1.opts.isRadiologicalConvention = !nv1.opts.isRadiologicalConvention;
		  event.srcElement.classList.toggle("dropdown-item-checked");
		  nv1.drawScene();
		  return;
		}
	  if (event.target.id === "ClipPlane") {
		  if (nv1.scene.clipPlaneDepthAziElev[0] > 1)
			nv1.setClipPlane([0.3, 270, 0]);
		  else nv1.setClipPlane([2, 270, 0]);
		  nv1.drawScene();
		  return;
		}
	  if (event.target.id.charAt(0) === "!") {
		  // set color scheme
		  //nv1.volumes[0].colormap = cmaps[i];
		  if (event.target.id.startsWith("!Ed")){
			EdColormap = event.target.id.substr(3);
			nv1.setMeshProperty(nv1.meshes[0].id, "edgeColormap", EdColormap)
		  } else {
			NdColormap = event.target.id.substr(3);
			nv1.setMeshProperty(nv1.meshes[0].id, "nodeColormap", NdColormap)
		  }
		  toggleGroup(event.target.id);
		  return;
		}
	  if (event.target.id.charAt(0) === "_") {
		  nv1.meshes = []; //close open meshes
		  // "_SC""_SClog""_SCCC""_SClogCC""_SCNE""_SClogNE"
		  let lbl1 = "fiber count";
		  let lbl2 = "strength";
		  if (event.target.id === "_SC"){ fname = "../src/Lausanne2_ROI_n_SC.jcon";}
		  else if (event.target.id === "_SClog"){ fname = "../src/Lausanne2_ROI_n_SClogfiber.jcon"; lbl1 = "log(fiber count)";}
		  else if (event.target.id === "_SCCC"){ fname = "../src/Lausanne2_ROI_n_SC_CC.jcon" ; lbl2 = "clustering coeff.";}
		  else if (event.target.id === "_SClogCC"){ fname = "../src/Lausanne2_ROI_n_SClogfiber_CC.jcon" ; lbl1 = "log(fiber count)"; lbl2 = "clustering coeff.";}
		  else if (event.target.id === "_SCNE"){ fname = "../src/Lausanne2_ROI_n_SC_NE.jcon" ; lbl2 = "nodal efficiency";}
		  else if (event.target.id === "_SClogNE"){ fname = "../src/Lausanne2_ROI_n_SClogfiber_NE.jcon" ; lbl1 = "log(fiber count)"; lbl2 = "nodal efficiency";}
		  await nv1.loadConnectomeFromUrl(fname);
		  nv1.document.labels[0].text = "edge: " + lbl1 + ",\n node: " + lbl2;
		  nv1.meshes[0].edgeColormapNegative = '';
		  nv1.origConnectome = nv1.meshes[0].connectome;
		  updateMeshes()
		  rNodebtn.onclick()
		  toggleGroup(event.target.id);
		}
  }
  // Update the current slider value (each time you drag the slider handle)
  edgeSlider.oninput = function () {
    nv1.setMeshProperty(nv1.meshes[0].id, "edgeScale", this.value*.1)
  }
  nodeSlider.oninput = function () {
    nv1.setMeshProperty(nv1.meshes[0].id, "nodeScale", this.value*.1)
  }
  // Here we suppose that the node and edge values are normalised in [0 1]
  NdThreshSlider.oninput = function () {
    nv1.setMeshProperty(nv1.meshes[0].id, "nodeMinColor", this.value * .01)
  }
  EdThreshSlider.oninput = function () {
    nv1.setMeshProperty(nv1.meshes[0].id, "edgeMin", this.value * .01)
  }
  let opts = {
    show3Dcrosshair: true,
    isColorbar: true,
	//isResizeCanvas: false,
    backColor: [0, 0, 0, 1],
	dragAndDropEnabled: false,
    //sliceType: niivue.SLICE_TYPE.RENDER,
	//multiplanarLayout: niivue.MULTIPLANAR_TYPE.GRID,
	multiplanarShowRender: niivue.SHOW_RENDER.ALWAYS,
	isOrientCube: true,
	showLegend: false,
	meshXRay: .3,
  }
  reset.onclick = function () {
    nv1.setDefaults(opts, true)
    nv1.setClipPlane([-0.0, 0, 40])
	nv1.setClipPlaneThick(1.73)
	nv1.volumes[0].colorbarVisible = false
  }
  var nv1 = new niivue.Niivue(opts);
  nv1.attachTo("gl1");
  await nv1.loadVolumes(volumeList1);
  await nv1.loadConnectomeFromUrl(fname);
  //   indexNearestXYZmm(Xmm: number, Ymm: number, Zmm: number): number[]  could be of interest
  // nv1.getAllLabels()
  var EdColormap = "Plasma";
  var NdColormap = "Plasma";
  nv1.setMeshProperty(nv1.meshes[0].id, "nodeColormap", EdColormap)
  nv1.setMeshProperty(nv1.meshes[0].id, "edgeColormap", NdColormap)
  nv1.meshes[0].edgeColormapNegative = '';
  nv1.setClipPlane([-0.0, 0, 40]);
  nv1.volumes[0].colorbarVisible = false;
  //nv1.setMeshProperty(nv1.meshes[0].id, "legendLineThickness", 2)
  //let AllLbl = nv1.getAllLabels();
  //for (var i = 0; i < AllLbl.length; i++){
//	AllLbl[i].style.textScale = .5;
  //}
  nv1.setClipPlaneThick(1.73)
  nv1.addLabel("edge: fiber count,\n node: strength", 
		{ textScale: .75, textAlignment: niivue.LabelTextAlignment.RIGHT, textColor: [1.0, 1.0, 1.0, 1.0], backgroundColor: [0.2, 0.2, 0.2, 0.2] }, 
		undefined, niivue.LabelAnchorPoint.TOPRIGHT);
  nv1.updateGLVolume()
  let nodes = nv1.meshes[0].nodes;
  nv1.origConnectome = JSON.parse(JSON.stringify(nv1.meshes[0].connectome)); // deep copy
  let rhROI_btns = document.getElementById("rhROI_btns");
  let lhROI_btns = document.getElementById("lhROI_btns");
  for (let i = 0; i < nodes.length; i++) {
	let btn = document.createElement("button");
		btn.innerHTML = nodes[i].name;
		btn.onclick = function () {
			// position crosshair at the center of the ROI
			let dPos = [nodes[i].x, nodes[i].y, nodes[i].z];
			dPos = nv1.volumes[0].mm2vox(dPos);
			const xhPos = nv1.frac2vox(nv1.scene.crosshairPos).slice(0, 3)
			console.log(xhPos)
			for (let j = 0; j < dPos.length; j++){
			  dPos[j] = dPos[j] - xhPos[j];
			}
			nv1.moveCrosshairInVox(dPos[0], dPos[1], dPos[2])
			// if node neighbourhood selected, then only display the connection sto this node
			if (document.getElementById('showNeigh').checked){
				showNeighbourhood(i)
			}
		};
	if (nodes[i].name.startsWith("R ")){
		rhROI_btns.appendChild(btn)
	} else{
		lhROI_btns.appendChild(btn)
	}
  }
  var rNodebtn = document.getElementById('showNd');
  rNodebtn.onclick = function (){
	for (let btnIdx=0; btnIdx < rhROI_btns.childNodes.length; btnIdx++){
		rhROI_btns.childNodes[btnIdx].style.backgroundColor = "";
	}
	for (let btnIdx=0; btnIdx < lhROI_btns.childNodes.length; btnIdx++){
		lhROI_btns.childNodes[btnIdx].style.backgroundColor = "";
	}
  }
  //lhROI_btns.childNodes[btnIdx].style.backgroundColor = ""
  var buttons = document.getElementsByClassName("viewBtn");
  for (let i = 0; i < buttons.length; i++){
	buttons[i].addEventListener("click", onButtonClick, false);
  }
  //nv1.updateGLVolume()
</script>